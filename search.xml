<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaScript中更简便的数组处理函数.map()，.reduce()，.filter()</title>
      <link href="/2019/11/02/frontend/simplify-your-javascript-with.html"/>
      <url>/2019/11/02/frontend/simplify-your-javascript-with.html</url>
      
        <content type="html"><![CDATA[<p>如果你刚接触JavaScript可能你还没有听说过<code>.map()</code>，<code>.reduce()</code>，<code>.filter()</code>。或者听说过，看过别人用过但是自己在实际项目中没有用过。在国内很多开发项目都是需要考虑IE8的兼容，为了兼容很多JavaScript好用的方法和技巧都被埋没了。但是我发现近几年开始，很多开发项目已经完全抛弃了IE这个魔鬼了。如果你不需要兼容古老的IE浏览器了，那就要开始熟悉一下这几个方法来处理数组。</p><blockquote><p>注意这遍文章说的的3个方法其实在很多其他语言都可以使用到，因为这几个方法和使用概念在很多其他语言都是存在的。</p></blockquote><hr><h1 id="map"><a href="#map" class="headerlink" title=".map()"></a>.map()</h1><p>让我用一个简单的例子告诉你如何使用这个方法。假如你现在有多对象的数组数据 - 每一个对象代表着一个员工的信息。现在你想要的最终结果就是取出所有员工的唯一ID值。</p><pre><code class="javascript">// 员工数据var employees = [  { id: 20, name: &#39;Captain Piett&#39; },  { id: 24, name: &#39;General Veers&#39; },  { id: 56, name: &#39;Admiral Ozzel&#39; },  { id: 88, name: &#39;Commander Jerjerrod&#39; }];// 你想要的结果[20, 24, 56, 88]</code></pre><p>其实要实现这个结果有很多数组处理方式。传统的处理方法就是先定义一个空数组，然后使用<code>.forEach()</code>，<code>.for(...of)</code>，或者是最简单的<code>.for()</code>来组装ID到你定义的数组里面。</p><p>我们来对比一下传统的处理方式和<code>.map()</code>的区别。</p><p>使用<code>.forEach()</code>：</p><pre><code class="javascript">var employeeIds = [];employees.forEach(function (employee) {  employeeIds.push(officer.id);});</code></pre><p>注意使用传统的方式，我们必须有一个预定义的空数组变量才行。但是如果是<code>.map()</code>就会更简单了。</p><pre><code class="javascript">var employeeIds = employees.map(function (employee) {  return employee.id});</code></pre><p>甚至我们可以用更简洁的方式，使用箭头方法（但是需要ES6支持，Babel，或者TypeScript）。</p><pre><code class="javascript">const employeeIds = employees.map(employee =&gt; employee.id);</code></pre><p>所以<code>.map()</code>到底是怎么运作的呢？这个方法有两个参数，第一是回调方法，第二是可选内容（会在回调方法中做为<code>this</code>）。数组里的<code>每个数值/对象会被循环进入到回调方法</code>里面，然后<code>返回新的数值/对象</code>到结果数组里面。</p><p>注意的是结果数组的长度永远都会和被循环的数组的长度一致。</p><hr><h1 id="reduce"><a href="#reduce" class="headerlink" title=".reduce()"></a>.reduce()</h1><p>与<code>.map()</code>相识，<code>.reduce()</code>也是循环一个回调方法，数组里面的每一个元素对回进入回调方法。区别是回调方法返回的值会被传递到下一个回调方法，如此类推（等同于一个累加器）。</p><p><code>.reduce()</code>里的累加值可以是任何属性的值，包括<code>integer</code>，<code>string</code>，<code>object</code>等等。这个累加值会被实力化或者传递到下一个回调方法。</p><p>来上代码，做个简单的例子！假如你有一个飞机师的数组，数组里面有每个飞机师的工龄。</p><pre><code class="javascript">var pilots = [  {    id: 10,    name: &quot;Poe Dameron&quot;,    years: 14,  },  {    id: 2,    name: &quot;Temmin &#39;Snap&#39; Wexley&quot;,    years: 30,  },  {    id: 41,    name: &quot;Tallissan Lintra&quot;,    years: 16,  },  {    id: 99,    name: &quot;Ello Asty&quot;,    years: 22,  }];</code></pre><p>现在我们需要知道所有飞机师累计的总工龄。使用<code>.reduce()</code>就是比吃饭还简单的事情。</p><pre><code class="javascript">var totalYears = pilots.reduce(function (accumulator, pilot) {  return accumulator + pilot.years;}, 0);</code></pre><p>注意我这里第二个参数我传了0。第二个参数是一个累加值的初始值。当然如果场景需要这个初始值也可以传入一个变量或者你需要的值。循环了数组里的每一个元素后，reduce方法会返回最终累加后的值（在我们这个例子中就是<code>82</code>）。</p><blockquote><p>例子里面的<code>acc</code>和<code>accumulator</code>就是累加值变量</p></blockquote><p>如果是使用ES6箭头写法，我们可以写的更加优雅简洁。一行就可以搞掂的事情！</p><pre><code class="javascript">const totalYears = pilots.reduce((acc, pilot) =&gt; acc + pilot.years, 0);</code></pre><p>现在如果我们需要找到哪一位是最有经验的飞机师。这种情况我们一样可以使用<code>.reduce()</code>。</p><pre><code class="javascript">var mostExpPilot = pilots.reduce(function (oldest, pilot) {  return (oldest.years || 0) &gt; pilot.years ? oldest : pilot;}, {});</code></pre><p>这里我把<code>accumulator</code>变量改为<code>oldest</code>代表飞机师里面的老司机。这时候reduce里面的回调方法对比每一个飞机师，每一次飞机师的值进入这个回调方法，工龄更高的就会覆盖<code>oldest</code>变量。最终循环后得到的<code>oldest</code>就是工龄最高的飞机师。</p><p>通过这几个例子，你可以看到使用<code>.reduce()</code>可以简单又优雅的在一个数组里面获取到单个最终值或者对象。</p><hr><h1 id="filter"><a href="#filter" class="headerlink" title=".filter()"></a>.filter()</h1><p>如果你现在的场景是需要在一个数组里面过滤一部分的数据，这个时候<code>.filter()</code>就是你的最好的朋友了。</p><p>我们用回飞机师的数据，并且加入了所属航空公司的值：</p><pre><code class="javascript">var pilots = [  {    id: 2,    name: &quot;Wedge Antilles&quot;,    faction: &quot;Rebels&quot;,  },  {    id: 8,    name: &quot;Ciena Ree&quot;,    faction: &quot;Empire&quot;,  },  {    id: 40,    name: &quot;Iden Versio&quot;,    faction: &quot;Empire&quot;,  },  {    id: 66,    name: &quot;Thane Kyrell&quot;,    faction: &quot;Rebels&quot;,  }];</code></pre><p>加入现在我们想分别筛选出<code>Rebels</code>和<code>Empire</code>两个航空公司的飞机师，使用<code>.filter()</code>就是轻而易举的事情！</p><pre><code class="javascript">var rebels = pilots.filter(function (pilot) {  return pilot.faction === &quot;Rebels&quot;;});var empire = pilots.filter(function (pilot) {  return pilot.faction === &quot;Empire&quot;;});</code></pre><p>就这么简单，如果使用箭头方法（ES6）就更加优雅了：</p><pre><code class="javascript">const rebels = pilots.filter(pilot =&gt; pilot.faction === &quot;Rebels&quot;);const empire = pilots.filter(pilot =&gt; pilot.faction === &quot;Empire&quot;);</code></pre><p>其实原理很简单，只要你的回调方法返回的是<code>true</code>，这个值或者对象就会在新的数组里面了。如果返回的是<code>false</code>就会被过滤掉了。</p><hr><h1 id="结合使用-map-，-reduce-，-filter"><a href="#结合使用-map-，-reduce-，-filter" class="headerlink" title="结合使用 .map()，.reduce()，.filter()"></a>结合使用 .map()，.reduce()，.filter()</h1><p>既然我们刚刚学到的三个函数都是可以用于数组的，并且<code>.map()</code>和<code>.filter()</code>都是返回数组的。那我们就可以串联起来使用。不说多了上代码试试！</p><p>我们用一个有趣一点的数据试验一下，假如现在我们有一个<code>星球大战</code>里面的<code>人物</code>的数组。每个字段的定义如下：</p><blockquote><ul><li><code>Id</code>: 人物唯一ID</li><li><code>name</code>: 人物名字</li><li><code>pilotingScore</code>: 飞行能力指数</li><li><code>shootingScore</code>: 射击能力指数</li><li><code>isForceUser</code>: 是否拥有隔空操控能力</li></ul></blockquote><p>我们的目标：获取<code>拥有隔空操控能力的飞行员的总飞行能力指数</code>。我们先分开一步一步实现这个目标！</p><ul><li>首先我们需要先获取到拥有隔空操控能力的飞行员。</li></ul><pre><code class="javascript">var jediPersonnel = personnel.filter(function (person) {  return person.isForceUser;});// 结果集: [{...}, {...}, {...}] (Luke, Ezra and Caleb)</code></pre><ul><li>这段代码我们获得了3个飞行员对象，分别都是拥有隔空操控能力的飞行员。使用这个对象我们来获取每个飞行员的飞行能力指数值。</li></ul><pre><code class="javascript">var jediScores = jediPersonnel.map(function (jedi) {  return jedi.pilotingScore + jedi.shootingScore;});// 结果: [154, 110, 156]</code></pre><ul><li>获取到每个飞行员的飞行能力指数值后，我们就可以用累加器（<code>.reduce()</code>）获取总飞行能力指数了。</li></ul><pre><code class="javascript">var totalJediScore = jediScores.reduce(function (acc, score) {  return acc + score;}, 0);// 结果: 420</code></pre><p>这里分开实现方式可以达到我们的目标，但是其实我们可以串联起来，可以写的更加简洁又优雅！我们来玩玩更好玩的吧！</p><pre><code class="javascript">var totalJediScore = personnel  .filter(function (person) {    return person.isForceUser;  })  .map(function (jedi) {    return jedi.pilotingScore + jedi.shootingScore;  })  .reduce(function (acc, score) {    return acc + score;  }, 0);</code></pre><p>这样写是不是很优雅！都被这段代码给美到了！❤️</p><p>如果我们使用箭头写法ES6，就更加优雅了！</p><pre><code class="javascript">const totalJediScore = personnel  .filter(person =&gt; person.isForceUser)  .map(jedi =&gt; jedi.pilotingScore + jedi.shootingScore)  .reduce((acc, score) =&gt; acc + score, 0);</code></pre><p>哇！代码原来可以写的那么优雅的么？！想不到吧？</p><blockquote><p>其实我们只需要使用<code>.reduce()</code>就可以得到我们的目标结果了，以上例子做为教学例子，所以使用了3个我们学到的函数。</p><p>我们来看看只用<code>.reduce()</code>怎么实现的，来我们一起来刷新一下三观吧！</p></blockquote><pre><code class="javascript">const totalJediScore = personnel.reduce((acc, person) =&gt; person.isForceUser ? acc + person.pilotingScore + person.shootingScore : acc, 0);</code></pre><p>不敢想象吧？一行就搞定一个功能不是梦！</p><h1 id="为什么抛弃-forEach"><a href="#为什么抛弃-forEach" class="headerlink" title="为什么抛弃 .forEach()?"></a>为什么抛弃 .forEach()?</h1><p>其实我一开始写前端的时候也是一顿撸，来个数组都是撸个for循环，解决一切数组处理问题。但是近几年我开始步入前后端开发，API接口对接。发现数据处理越来越多，如果还是像以前那样什么都用for循环来处理数据，那其实数据处理的代码就会越来越臃肿越来越复杂凌乱。所以我开始抛弃了<code>.forEach()</code>。开始做一个优雅的程序员！</p><p>为什么使用<code>.map()</code>，<code>.filter()</code>，<code>.reduce()</code>写代码更优雅，更美观呢？我们用一个实战例子来对比一下吧。</p><p>假设现在我们对接一个接口，返回的数组里面有两个字段<code>name：人的名称</code>和<code>title：对应的职位</code>。</p><pre><code class="javascript">var data = [  {    name: &quot;Jan Dodonna&quot;,    title: &quot;General&quot;,  },  {    name: &quot;Gial Ackbar&quot;,    title: &quot;Admiral&quot;,  },]</code></pre><p>产品经理给到你的需求是只需要展示这些人的职位称呼。</p><blockquote><p>当然这个时候有一些前端就会说“我只是个小小的前端，后端给我处理吧”。但是，这个接口其实是一个通用的接口，就是获取这些员工的资料的，是在多个地方使用的。如果每一个页面因为需要展示的不一样而要写多一个接口给你，你觉得这样好吗？做为一个优秀的前端工程师🦁️，这种小case你自己就可以很优雅的处理好了。而且，在一个优秀的团队，后端确实是要考虑接口通用性的，这种为了你的方便而给他们带来更臃肿的接口是不可接受的。所以前端这个时候就是要重组数据了。</p></blockquote><p>假设现在产品给你的需求是员工列表展示，要支持只展示员工职称和员工左右信息的两种显示项。这个时候我们就要编写一个数据组装方法来跟进展示要求来改变数据格式。</p><p>因为这个“神马“的需求，我们使用<code>.forEach()</code>来重组数据就相对比较麻烦了，而且代码也会变得臃肿。</p><p>我们忽略了组装数据的方法，直接就当作我们已经写好了一个组装数据的方法为<code>formatElement</code>。如果我们用<code>forEach</code>首先我们就需要定义一个空数组来接收结果。</p><pre><code class="javascript">var results = [];data.forEach(function (element) {  var formatted = formatElement(element);  results.push(formatted);});</code></pre><p>所以我们需要两个方法才能实现这个数据结果，但是为什么要写的那么臃肿呢？因为<code>forEach</code>并没有返回值，单单就给你跑个循环，还需要自己<code>push</code>值到预定义的变量里面。其实一个方法就可以完成了，而且重点是一行代码就完事了。</p><p>来使用我们新学的技巧，用<code>.map()</code>来实现就非常简单优雅了。</p><pre><code class="javascript">var results = data.map(formatElement);</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>你学会了吗？学会了就去尝试用<code>.map()</code>，<code>.reduce()</code>，<code>.filter()</code>来替换你传统的<code>for</code>循环吧！我保证你的代码会越来越简洁，可读性更高。</p><p>如果你喜欢我的这遍文章，记得继续关注我的博客，下一遍文章我们开学习怎么在JavaScript中使用<code>.some()</code>和<code>.find()</code>。</p><p>坚持做一个优雅的程序员，坚持每天敲代码！</p>]]></content>
      
      
      <categories>
          
          <category> FrontEnd </category>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何高效学习编程</title>
      <link href="/2019/11/01/notes/learn-programming-more-effectively.html"/>
      <url>/2019/11/01/notes/learn-programming-more-effectively.html</url>
      
        <content type="html"><![CDATA[<p>编程确实不是一件容易的事情，除了要有较强的<code>逻辑思维</code>，还需要<code>花大量的时间和集中力来提升和维持一定的高度</code>。</p><p>与其他的领域不一样的是，技术每日都在变，所以对于编程初学者是很难一直与时并进的。就算是技术大神和老司机们也是追赶的比较吃力的。在技术领域打滚的这些年里，通过经历和经验总结出一些高效的学习方式和方法，在这篇文章里与大家分享。让我们现在就在技术领域的学习之路上奔跑吧！</p><h1 id="锁定目标，风雨兼程"><a href="#锁定目标，风雨兼程" class="headerlink" title="锁定目标，风雨兼程"></a>锁定目标，风雨兼程</h1><p>在刚刚接触技术的时候，很多人都会比较迷茫。技术领域有前端后端并且各自有多种编程语言。选定前端后端后又发现越过一山还有一山高，面临更多的选择。甚至在技术领域打滚了多年后的技术人员也会迷茫，会开始质疑自己的前景，是否要换一门语言或者多学几门语言。所以锁定目标是高效学习的第一门课。</p><h2 id="选择目标"><a href="#选择目标" class="headerlink" title="选择目标"></a>选择目标</h2><p>如果你的目标是前端开发，前期的学习道路是比较明确的，HTML5+CSS3起步。但是如果你的目标是后端开发，还没有开始就已经有多扇门在你前面，让你瞬间选择困难了。所以这里我们就用后端语言选择作为一个例子讲解学习目标选择方法。</p><blockquote><p>陷入学习目标选择困难症是因为技术每日每夜都在变，方向和未来都在摇摆。但是我们首先要有一个对技术有很好的判定能力。</p></blockquote><p>大家应该很多时候都听过”JAVA才是世界上做好的语言”，”PHP才是世界上最好的语言”等等，这些在自己领域崇拜着自己所爱的语言技术爱好者。TA们并没有错，因为每个开发语言都在特定领域或者项目条件里是最好的语言。不过并<code>没有世界上最好的语言，只有在某一个场景和条件下最适合使用的语言</code>。每一种开发语言都有他擅长最合适的使用场景。</p><ul><li><code>PHP</code> - 更适合小型到中型网页端应用（大型应用就需要其他语言配合使用）</li><li><code>JAVA</code> - 更适合大型应用，企业级应用（中小型应用用JAVA就是大材小用，浪费资源）</li><li><code>PYTHON</code> - 更适合用于爬虫，人工智能，脚本类应用</li></ul><hr><blockquote><p>📖 <strong>目标寻找法：</strong></p><p>所以在选择学习目标的时候，我们要有对技术的判定能力，不要轻易听取一些偏面的评价和定论而下决定。</p><ul><li>选择学习目标时重要的决定因素:<ul><li>在目前最实用的 <em>- 学能用到的更容易上手，也更有价值</em></li><li>难度跨度不要太高 <em>- 难度跨越太大时间成本会越高</em></li><li>感兴趣的 <em>- 感兴趣才更能坚持，更有动力</em></li><li>社区更大的 <em>- 社区越大遇到问题时找答案的途径越多</em></li><li>开源项目优先 <em>- 开源的项目的技术更有未来</em></li></ul></li></ul></blockquote><p>🎯 一旦锁定一个目标就要<code>能懂，能用，能变</code>，再扩张你的学习领域到其他的技术。</p><ul><li><code>能懂</code> - 能懂的技术或者知识的理论和原理；</li><li><code>能用</code> - 能把技术或者知识投入使用，投入实战项目；</li><li><code>能变</code> - 能举一反三学到的技术或者知识，能变通，延伸拓展。</li></ul><hr><h2 id="不要蜻蜓点水"><a href="#不要蜻蜓点水" class="headerlink" title="不要蜻蜓点水"></a>不要蜻蜓点水</h2><p>这一点是很多初学者都会犯的错误。</p><blockquote><p>不要<code>浅入浅出，得不偿失</code>，得不到技能还失去了时间。</p></blockquote><p>学习要一步一个脚印，很多一开始学习编程往往会同时学习多个技术，其实这种学习方式不但没有效果反而还浪费时间浪费生命。锁定一个学习目标就要专注一个点上学习，重点学习。</p><p>举个例子，如果你想成为一个Java开发工程师，你是不需要从C学起，然后C++，最后才开始学习Java。我看到很多开发者刚开始都是这样学习，其实根本不需要从底层技术开始学习。既然你的学习目标是Java，那就直奔重点不浪费时间。稳固了基础开发语言后，选择一个框架开始深入专业实战知识。当你稳固了更专业的实战知识后，就可以开始学习这个技术的周边工具（比如IDE）让开发更加高效便捷。</p><blockquote><p>📖 <strong>专研秘诀：</strong></p><ul><li>学习每一个知识或者技术，一定要深入浅出，<code>深入学习和挖掘，吸取重要知识和技术</code>。</li><li><code>专心</code>，<code>专注</code>，<code>专研</code>是一个技术人才的基本素养！</li></ul></blockquote><hr><h2 id="先专注于会用而不是能用"><a href="#先专注于会用而不是能用" class="headerlink" title="先专注于会用而不是能用"></a>先专注于会用而不是能用</h2><p>很多开发者习惯性会过于专注于工具使用，写法，性能，可扩展性等等。初学者一般都会掉入工具使用和写法的坑，而资深的开发者会过于专注于性能和可扩展性。这时候往往会过度消耗学习时间，甚至忘记最初的学习目标。</p><p>用一个简单易懂的例子，”一个机械工程师不会浪费时间想怎么更好的使用TA的扳手，而是怎么可以组装好一个机器的部件” - 很多人会想，学会用更好的工具不是可以更快地安装好吗？但是现实是，你都还没有弄懂怎么安装，再好再有效的工具对你来说都是无用武之地。所以<code>还没有学会前行，就不要先想着怎么跑</code>。</p><p>再举例，如果你是正在学习使用Vue框架，不要太过于执着怎么使用Vue的周边工具，高级写法，性能隐患问题等等。你的目标应该是创建你的第一个首页然后直接投入开发一个小项目小应用。这样你的产出才是最高的，因为这样做更加专注于学会怎么使用Vue来实现功能，而不是更好的使用Vue框架。</p><blockquote><p>在学习的时候要专注于<code>会使用新的技术</code>，而不是怎么用各种花式技巧来<code>提高使用能力</code>。</p></blockquote><p>还有很多童鞋开始学一门技术时，会先开始看一大堆的知识和书籍，或者去看一些大型的项目用这个技术是怎么实现的。其实更<code>有效的学习方式是小步快跑</code>，学习的过程中开发一个小项目会让你更加有动力也更有趣。</p><p>约定自己在限定时间内完成小目标，如能完成就给自己一点小奖励。例如，你对你自己说“如果我下周五完成这个功能，我就让自己去看个电影”。记住奖励不需要很大，<code>小步快跑，小奖小利</code>，这样才能维持发自内心的动力和驱动力。不过就算没有达成小目标也不用气馁，失败时成功之母，所有成功的人都是通过在失败中总结成长壮大。</p><hr><h1 id="采用学习策略"><a href="#采用学习策略" class="headerlink" title="采用学习策略"></a>采用学习策略</h1><p>每一个人都会有一种最合适自己的学习方式方法，适合我的不一定对你就有效 - 所以找到一种对你有效的学习方法很重要。</p><h2 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h2><p>学习方式方法是通过你日复一日，年复一年不停地尝试和总结得来的一种技巧。我也尝试过很多种方式来学习技术，自从我开始进入技术行业到现在，我换了无数种学习方式才找到最适合自己的一种技巧。</p><p>在一开始刚刚入门的时候，我尝试看很多“从入门到精通”，“XXX语言101”等等，最终的结果都是“从入门到放弃”。后面开始走视频学习之路，发现视频里面的老师说话好像是机器人一样，本来有点失眠症的，没想到一看视频秒睡着，被治好了！我以为我的技术生涯就要结束在这里了～ <code>¯\_(⊙︿⊙)_/¯</code></p><h2 id="建立策略"><a href="#建立策略" class="headerlink" title="建立策略"></a>建立策略</h2><p>前方无绝路 · 希望在转角 ～ 我迅速改变了策略，学习技术和其他领域不一样除了看书，撸视频还需要动手去敲代码。<code>学习任何一门技术，可以遵循以下学习策略，可以让学习的技术和知识更加稳固。</code></p><blockquote><p>📖 <strong>学习策略：</strong></p><p>还是遵循我们之前说到的规则，<code>能懂，能用，能变</code>。</p><ol><li><code>深入了解技术的原理</code> - 了解清楚才能更好的在不同场景下运用自如（可以通过看书，看文档）</li><li><code>通过代码理解运用方式</code> - 看懂基本原理，就可以看看别人是怎么在项目中使用的（在github找开源项目，看教学视屏等等）</li><li><code>实战，做一个小项目</code> - 能懂，能会了就要能用，用新学的技术实现一个功能，做一个小项目，把知识投入实战。</li><li><code>发挥你的想象力</code> - 能用后如果想进阶更高层次，就要发挥你的想象力，能举一反三，在你的小项目里面加功能。</li></ol></blockquote><p>其实上面的策略无非就是学习的过程中必须有的<code>理论</code>，<code>运用</code>和<code>变通</code>。这三个学习维度要保持一个良好的平衡。这个平衡是非常重要的，只有理论那就是“纸上谈兵”，只有理论和运用那只是个“代码搬运工”，如果三个维度你都才是就是“大师”。</p><p>当然所说的平衡不是说1:1:1，完全平衡是很难的。对于一个初学者的话可以先3:2:1，中级就可以开始维持2:3:1，到了高级就可以维持2:2:2了。</p><hr><h1 id="时间管理，提高效率"><a href="#时间管理，提高效率" class="headerlink" title="时间管理，提高效率"></a>时间管理，提高效率</h1><p><code>番茄工作法</code>估计很多人都听说过，但是真正用上可能就很少了，能坚持使用的就更少了。</p><p>很多时候在学习中，或者工作中，我们都是被时间追着跑，这里看一下哪里看一下，不经意就已经过了几个小时，一天就过去了。其实真正有效的产出不大，那是因为你没有合理的管理时间。用番茄工作法就是可以让我们可以追着时间跑，让自己时刻有着时间感，急迫感。自然时间运用上就更加有效了。我现在工作中和学习中都已经在使用番茄工作法，有效管理时间效率。突然发现使用了之后，每个小时我的工作效率提高了很多。</p><blockquote><p>使用方式其实很简单，把学习或者工作时间拆分为<code>25分钟一个小阶段，每25分钟休息5分钟，每4次小阶段休息15到20分钟</code>。</p></blockquote><p>使用这个时间管理法后，你会觉得在25分钟的小阶段里面，你的时间很紧迫的，每一分钟你都觉得很宝贵。你会发现你没有时间去浪费，自然而然的在25分钟内提高了效率。无形中你的学习和工作的集中力就会提升。除了提高了你的效率以外，你会发现一天几个小时的学习或者工作都不觉得很疲惫。因为在25分钟的高度集中后，你合理的调整了休息，让自己非常平衡的控制好疲惫度。所以你会发现一天里面的学习和工作都变得轻松了。</p><blockquote><p>使用番茄工作法提高了学习效率和疲惫度，自然你的学习成果就会更高。如果你觉得我说的这个方法太虚幻了，不妨试一下体验一下，实战说明一切！</p></blockquote><hr><h1 id="多思考，多教学"><a href="#多思考，多教学" class="headerlink" title="多思考，多教学"></a>多思考，多教学</h1><p>通常我们学习都用的是吸🌟大法 <code>🌟ԅ( ͒ ۝ ͒ )</code>，然后实战运用，其实还有很多细节和理论我们并没有理解透测。所以运用就不够自由，无法延伸一些创新的用法，或者举一反三。</p><p>在我事业发展的过程中，从一个小开发，做到一个小组长，到现在技术总监。在我开始带领一个小组，到带领整个技术团队；很多问题和新知识都要通过讲解或者教学来带培养你的组员和队员。这个过程中会遇到各种不同思维程度和学习能力的人，每一个人的理解能力或者理解方式都不一样，甚至看待每一件事情或者知识的角度都不一。你会发现你教学或者讲解某一个知识的时候需要使用各种不同的方式和方法。往往就是这样触发了你自己去换角度思考和理解这个知识，而启发了你自己对这个知识新的认知。</p><blockquote><p>通过教学和讲解来把你的知识传承给另外一个人，需要重新整理思路，逻辑，切换N中方式和说法。这个过程中你会挖掘出新的知识，新的观点，新的思维方式，新的理解角度和深度。这就是自我思维切换而达到的知识深度挖掘和提升的过程。这种就是我们经常说的<code>小黄鸭教学法</code>。</p></blockquote><p>不知道大家有没有听说过，当你思路不清晰，或者有问题无法解决的时候。你可以找一只<code>小黄鸭</code>，你就开始讲解你的思路，逻辑或者问题。这个过程中你开始重新整理自己的思路。如果你把一只啥都不懂的小黄鸭也能让它听懂。那这个时候你的思路，逻辑，理解都更加清晰了，问题起码都解决了50%以上了。我给这个方法取了个名字叫<code>小黄鸭教学法</code>！初级学习的时候要用<code>吸星大法</code>，进阶到高级的时候就要用<code>小黄鸭教学法</code>。能教会一只小黄鸭技术，你就是大神了！</p><hr><h1 id="记录，总结"><a href="#记录，总结" class="headerlink" title="记录，总结"></a>记录，总结</h1><p>除非你是过目不忘，要不看完一本书能记下所有是不可能的。就算记住了但是不可能完全明白透彻。一个程序员经常面对着反复又反复的任务，记录学习进度和总结学习知识很重要。往往你学到一个知识的时候，你会使用这个知识投入实战中。你沉迷在代码海洋之中无法自拔之后，你会发现你已经不记得你入海前学到哪里了。所以记录学习进度很重要。</p><blockquote><p><strong>记录学习方式：</strong></p><ul><li>把学习后的只是写成文档</li><li>把知识写成博客</li><li>总结重点，记录重点</li><li>编写学习规划，就是所谓的<code>todo</code>规划表</li></ul></blockquote><p>在学习中，如果要把知识记录，当你要使用它的时候能快速找到。那你就要有总结知识的习惯。把你学过的知识，技术，技巧都写成文档，写成总结。这样加强你的印象，同时也整理出了属于你自己的开发手册。当你遇到了某些问题的时候就可以通过你自己的开发手册找到答案。</p><hr><h1 id="改掉以下习惯"><a href="#改掉以下习惯" class="headerlink" title="改掉以下习惯"></a>改掉以下习惯</h1><ul><li><strong>完美主义：</strong> 初学者经常会陷入的一个坑，从一开始就追求完美，完美的写法，完美的实现方式，完美的设计模式。其实有时候这些都不是最重要的，反而导致有延迟和延后的严重情况，导致进度一直无法推进。最求完美往往把简单事情变得复杂。不要总是为了完美而无限徘徊，为了最好的解决办法而纠结，为了对的方式而浪费时间。往往在开发中，<code>时间是有限的，需求是无限的，连完成都无法保证，就更没有时间追求完美</code></li><li><strong>对比心态：</strong>很多行业内的新人或者准备入行的，都会去和行业内顶尖的人做对比。有一句很火的话“没有对比就没有伤害”，很多人用来对比好与坏，美与丑。其实另外层意思就是如果对比会对你自身造成打击又何必常常带着对比之心来对待自己和事情呢？对比不一定会有伤害，但是对比的心态才是真正造成伤害的源头。应该先认可自己的优点，接受自己的缺点，然后去找到别人的优点，发现别人的缺点。在别人的优点和缺点给自己带来成长。吸收别人优点，避免自己养成了同等的缺点。<code>优秀的人不是天生比你优秀，而是TA们更懂的不自我透支，更懂得养成在无形之中让自己成长的习惯。</code></li><li><strong>复杂化：</strong>学会把复杂的问题和事情拆分成多个小问题小事情。复杂的问题和事情就会变得更加简单。因为问题和事情往往有多个点需要突破，把每个点拆开逐个突破就会更加简单轻松。<code>从简到繁，如果太复杂，就拆开一个一个更简单的小点，逐个突破。</code></li><li><strong>悲观心态：</strong> 很多人遇到巨大难题时都会来一句“没有办法，做不到”。如果做不到，无论何事，都是自己还没有真正想做！<code>没有做不到的事，只有自己不想做的！失败究其必有原因！成功必有方法！</code></li><li><strong>过度透支：</strong>学习累了就躺穿上休息，吃饱喝足了就坚决不吃了。养好一种自律的习惯，不过度透支自己的时间和生命，这样才能有更好的精神和态度面对问题和困难。近年来有很多给程序员打上的标签，”加班狗”，“无日无夜写代码”，“生活邋遢”，“衣服全是同款黑色”等等。确实，做为一个程序员，我们花了大部分时间都在想问题，编写者神乎奇幻代码和程序。但是我们都往往忘记了自己的身体已经在一点一点透支。到了那一天你停下来了，你会发现，身体不行了，除了写代码其他个方面的能力都没有时间去提升。也没有劲学习成长了，整个人好像很颓废，生无可恋一样。所以<code>学会不透支自己，才有更好的状态和精力学习和突破自己。</code></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>无论你是在学习技术还是在学士任何其他领域的知识。在学习这条路上都会有坑坑洼洼，各种颠簸。所以我们学习要有技巧，要有方法才能在有效时间内收获最大化！</p><blockquote><p><strong>学习法门：</strong></p><ol><li>锁定目标 <em>- 选择有用的，对你现在阶段有价值的目标</em></li><li>采用学习策略 <em>- 深入学习，投入实战，总结经验</em></li><li>管理好时间 <em>- 把控好时间，提高效率</em></li><li>多思考，多总结 <em>- 多思考问题，多总结和记录知识</em></li><li>改掉不好的习惯和心态 <em>- 有好的习惯才能更轻松的学习和成长</em></li></ol></blockquote><p>一个人一生是有学不完的知识和技能，然而人一生的时间是有限的。所以要把我们的时间和收益最大化才能比同年龄的人跑的更快，学的更多，能力更强！大家一起在学习的道路上继续加油吧！</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learning </tag>
            
            <tag> Programming </tag>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>真正的`服务层`是怎么写的?</title>
      <link href="/2019/10/19/backend/how-to-write-a-service.html"/>
      <url>/2019/10/19/backend/how-to-write-a-service.html</url>
      
        <content type="html"><![CDATA[<p>其实很多系统架构里面都有服务层，但是服务对很多开发人员来说都有很多不同的定义和写法。甚至在我待过的公司里都有不同的写法和编写模式。每个人每个团队每个项目都有对服务不同的理解。那到底什么是服务，怎么理解才是对的呢？</p><p>你们有没有过无数个夜晚里严重怀疑人生，琢磨着到底哪一种服务才是对的？哪一种才是最好的写法，哪一种才能达到服务的真正意义？因为这种执着，我开始在国外的各种网站，大神们写过的开源大项目里面和文章里面总结出一个大多数研发伙伴们认可的理解方式和编写方式。</p><p>要理解什么是服务，我们先来给<code>服务</code>一个<code>定义</code>，在系统架构里面处于什么<code>角色</code>，<code>作用</code>是什么。</p><hr><h2 id="服务定义"><a href="#服务定义" class="headerlink" title="服务定义"></a>服务定义</h2><blockquote><p><code>角色</code>：服务是系统架构里面的业务处理层。<br><code>作用</code>：主要是为了高度解耦和封装不同场景的业务和功能到对应的服务，然而达到高度中心化的业务代码。</p></blockquote><p>这个定义没毛病吧？赞同的童鞋在评论里举个手哈 👋。<br>好，有了一个优雅高尚的<code>服务定义</code>，我们来用一个通俗易懂的例子来理解服务。</p><hr><h2 id="理解服务"><a href="#理解服务" class="headerlink" title="理解服务"></a>理解服务</h2><ul><li>假设<code>人</code>是一个<code>控制器</code>，现在拿到了一个<code>衣服对象</code>的<code>参数</code>，然后人拥有一个<code>洗衣服</code>的<code>方法</code></li><li>现在人需要洗衣服，但是手洗效率太低了，所以我们写了一个多功能的<code>洗衣机服务</code>给到人去使用</li><li><code>洗衣机</code>这个服务里面有很多不同洗衣服的<code>方法</code>，但是其实具体洗衣机里面的每一个清洗方法人是不知道怎么实现的，人都是直接按照提供的功能直接使用。</li><li>所以所有服务里面的方法都是解耦在服务里面，服务要提供的方法是可以方便人使用的。</li></ul><hr><p>这样说是不是很好理解了？所以最简单的理解就是：</p><blockquote><p>服务是用来封装业务逻辑代码，是一个独立的逻辑层，高度封装解耦后提供给控制器或者其他需要用到这个服务的地方使用的。</p></blockquote><hr><h2 id="编写思路"><a href="#编写思路" class="headerlink" title="编写思路"></a>编写思路</h2><p>❌ <code>错误例子</code></p><blockquote><p>把所有洗衣机的方法提供给人使用，那就等同于让人来决定所有洗衣机的参数和清洗步骤。那人放衣服到洗衣机后，要选择先加水，加多少水，然后清洗开始，清洗多久，再甩干等等。</p></blockquote><p>就想想这个洗衣机就不想用了，洗个衣服那么多选项，还要想那个设置顺序才是对的！ 我太难了！洗个鸡腿哦！(ﾉ｀□ ´)ﾉ⌒┻━┻</p><p>⭕️ <code>正确例子</code></p><blockquote><p>洗衣机服务实现了很多不同的常用洗衣服的<code>模式</code>, 比如快速清洗，毛衣清洗，地毯清洗，风干，甩干等等。都是一些常用的功能。<br>每个功能方法里面其实调用了很多洗衣机封装好的流程和方法。这样人使用洗衣机根本不需要知道这些功能是怎么实现的，只要知道自己要干嘛，洗衣机有这个模式，直接用就好了。</p></blockquote><p>(✧ᗜ✧)👍哇！ 介么人性化的么！这种洗衣机给我来一打谢谢！<br>思路我们整理清楚了，那么可以开始看看用这种思维模式写成代码是怎么样的。来上机械键盘，开始快乐滴敲代码了！</p><h2 id="服务写法"><a href="#服务写法" class="headerlink" title="服务写法"></a>服务写法</h2><h3 id="Controller-控制器"><a href="#Controller-控制器" class="headerlink" title="Controller 控制器"></a>Controller 控制器</h3><p>首先我们写一个人控制器<code>PersonController.php</code>，作为一个优秀的人类，我们天生就会洗衣服，但是人嘛天生就是懒惰的。所以我们买了一台洗衣机（实现洗衣机<code>服务</code>）并且我们学会了使用洗衣机来洗衣服。（实现<code>wash</code>方法）٩(◦`꒳´◦)۶</p><blockquote><p>一个人<code>PersonController</code>，有一个洗衣服方法<code>wash</code>，需要洗衣服的时候实例洗衣服务<code>new WashingMachineServer()</code>，然后只要把衣服传入洗衣机服务的快洗方法，洗衣机服务就会开始快速<code>quickWash($cloth)</code>清洗了。</p></blockquote><pre><code class="php">// 人控制器class PersonController{    /**    * 洗衣服方法    *     * @param object $cloth 衣服对象    */    public function wash($cloth)    {        $washingMachine = new WashingMachineService();        $washingMachine-&gt;quickWash($cloth); // 调用洗衣机的快速清洗功能    }}</code></pre><p>我们好奇的童鞋们，肯定会好奇，那这个洗衣机（<code>WashingMachineService.php</code>服务) 到底是怎么实现的呢？它的快洗功能是怎么做的呢？那我们就来自己建一部洗衣机，自然就懂了。</p><h3 id="Service-服务"><a href="#Service-服务" class="headerlink" title="Service 服务"></a>Service 服务</h3><p>动手之前我们要先思考，先分析，养成这样的好习惯，代码再也不难写了。</p><blockquote><p>分析的重点分为服务的<code>运作</code>和<code>流程</code>, 可变动的<code>属性</code>，最后就是有那些可以提供的<code>模式</code>。 </p></blockquote><ul><li><strong>洗衣机应该怎么<code>运作</code>和<code>流程</code>的：</strong><ol><li>把衣服放入洗衣机 <code>addCloth()</code></li><li>注入水到洗衣机里 <code>addWater()</code></li><li>开始洗衣服（开始旋转和各种累活）<code>wash()</code></li><li>把水排除洗衣机 <code>flushWater()</code></li><li>把衣服取出 <code>fetchClouth()</code></li></ol></li><li><strong>洗衣机可变动的<code>属性</code>：</strong><ul><li>要把衣服放入洗衣机，我们就需要有个东西来装着，然后才能清洗，所以我们应该有一个洗衣桶 <code>$bucket</code></li><li>根据衣服的量，使用的水量是应该可以调节的。（对我们要节约用水嘛）<code>$washDuration</code></li></ul></li><li><strong>洗衣机最常用的<code>模式</code>：</strong><ul><li>快速洗 <code>quickWash()</code></li></ul></li></ul><hr><blockquote><p><strong>⚠️ 需要注意：</strong>  </p><ul><li>所有洗衣机的内部方法都是 <code>private</code> 私有方法，因为都是给洗衣机使用的，外部的人是不能使用的；</li><li><code>快速清洗</code>和<code>取衣服</code>这两个方法是 <code>public</code> 共有方法，因为是洗衣机提供出去给人使用的方法；</li><li>所有属性都是 <code>protected</code> 保护属性，是洗衣机独有的属性。</li></ul></blockquote><p>现在我们就要使用程序员的魔法，把以上的逻辑和属性转换成代码。<code>(∩◉ω◉)⊃----★</code></p><pre><code class="php">class WashingMachineService{    /**    * 清洗时长 (分钟)    * @var integer    */    protected $washDuration = 60;    /**    * 洗衣机的洗衣桶    * @var array    */    protected $bucket;    /**    * 改变默认洗衣机的清洗时长    * @param integer $duration    */    public function changeWashDuration($duration)    {        $this-&gt;washDuration = intval($duration);        return $this;    }    /**    * 往洗衣机的桶加入水    */    private function addWater()    {        array_merge($this-&gt;bucket, [&#39;water&#39; =&gt; &#39;cold water&#39;]);        return $this;    }    /**    * 把衣服加入洗衣机桶内    */    private function addCloth($cloth)    {        array_merge($this-&gt;bucket, [&#39;cloths&#39; =&gt; $cloth]);        return $this;    }    /**    * 旋转桶把开始洗衣服    */    private function wash()    {        // 使用洗衣机的清洗时长来全换清洗衣服        for ($duration = $this-&gt;washDuration; $duration &gt; 0; $duration--) {            array_rand($this-&gt;bucket, 3);        }        return $this;    }    /**    * 把桶里面的水清除掉    */    private function flushWater()    {        unset($this-&gt;bucket[&#39;water&#39;]);        return $this;    }    /**    * 从洗衣桶里面把衣服拿回出来    */    private function fetchCloths()    {        return $this-&gt;bucket[&#39;cloths&#39;]    }    /**    * 快速清洗衣服方法    */    public function quickWash($cloth)    {        return $this-&gt;changeWashDuration(10) // 重新设置洗衣服的时长                    -&gt;addCloth($cloth) // 加入衣服                    -&gt;addWater() // 加入水                    -&gt;wash() // 开始清洗                    -&gt;flushWater() // 清除水                    -&gt;fetchCloths(); // 最后取出衣服返回    }}</code></pre><p>以上就是一个最基础的服务，有独立的内部方法可以让服务运作起来，也有提供出去的服务模式方法。</p><blockquote><p><strong>⚠️ 需要注意</strong>:<br>服务的重点特性在最后这个 <code>quickWash</code> 快速清洗方法。实现快速清洗是通过使用特定<code>顺序</code>和<code>组合</code>方式调用洗衣机<code>内部方法</code>。这种服务的实现方式，可以把一个服务里面的业务逻辑拆分成多个逻辑块，然后通过不同的顺序和组合来实现某种模式或者功能。这样的服务就非常有弹性，而且所有逻辑块复用性极高。这个也是设计模式里面的<code>模版方法模式（Template Method）</code>。</p></blockquote><p>上面的例子只是写了一个洗衣机10%不到的功能，一个完整的洗衣机还会有很多的逻辑方法。那问题就来了，方法多了这个服务就会开始臃肿。这个时候我们就要想一套解耦封装服务的方式方法。接下来我们来讲解一下怎么更深度的服务封装。</p><hr><h2 id="服务封装"><a href="#服务封装" class="headerlink" title="服务封装"></a>服务封装</h2><p>在日常开发过程中，我们有各种各样的封装和解耦方式。包括<code>内部Trait</code>, <code>内部服务</code>，<code>工厂设计模式</code>。这几种都是可以用来深度封装服务的方式方法。找到了方法，下一步就是要找到怎么封装才是最优解耦思路。解耦的原理就是找到<code>共通点</code>和<code>公用点</code>。然后把这些方法封装起来，解耦出去。</p><h3 id="封装思路"><a href="#封装思路" class="headerlink" title="封装思路"></a>封装思路</h3><blockquote><p>在上面写的洗衣机服务，里面的洗衣桶是很通用的和独立的业务逻辑。所以它是可以解耦封装在一起的。</p><ul><li>洗衣机的<code>bucket</code>洗衣桶属性的方法其实可以封装起来。单独做为一个洗衣桶的服务。</li><li>所有涉及洗衣桶操作的功能和流程都封装到洗衣桶服务里面给洗衣机调用。</li></ul></blockquote><p>使用上面的逻辑，我们可以把<code>洗衣机服务</code>和<code>洗衣桶服务</code>拆分成两块。来吧上机械键盘！</p><hr><h3 id="封装编写"><a href="#封装编写" class="headerlink" title="封装编写"></a>封装编写</h3><ul><li>洗衣机服务 <code>WashingMachineService.php</code></li></ul><pre><code class="php">class WashingMachineService{    /**    * 清洗时长 (分钟)    * @var integer    */    protected $washDuration = 60;    /**    * 改变默认洗衣机的清洗时长    * @param integer $duration    */    public function changeWashDuration($duration)    {        $this-&gt;washDuration = intval($duration);        return $this;    }    /**    * 快速清洗衣服方法    */    public function quickWash($cloth)    {        $washingBucket = new WashingBucketService();        $this-&gt;changeWashDuration(10) // 重新设置洗衣服的时长        // 调用洗衣机的桶去清洗衣服        return $washingBucket-&gt;addCloth($cloth) // 加入衣服                    -&gt;addWater() // 加入水                    -&gt;wash($this-&gt;washDuration) // 开始清洗                    -&gt;flushWater() // 清除水                    -&gt;fetchCloths(); // 最后取出衣服返回    }}</code></pre><ul><li>洗衣桶服务 - <code>WashingBucketService.php</code></li></ul><pre><code class="php">class WashingBucketService{    /**    * 洗衣机的洗衣桶    * @var array    */    protected $bucket;    /**    * 往洗衣机的桶加入水    */    public function addWater()    {        array_merge($this-&gt;bucket, [&#39;water&#39; =&gt; &#39;cold water&#39;]);        return $this;    }    /**    * 把衣服加入洗衣机桶内    */    public function addCloth($cloth)    {        array_merge($this-&gt;bucket, [&#39;cloths&#39; =&gt; $cloth]);        return $this;    }    /**    * 旋转桶把开始洗衣服    */    public function wash($washDuration)    {        // 使用洗衣机的清洗时长来全换清洗衣服        for ($duration = $washDuration; $duration &gt; 0; $duration--) {            array_rand($this-&gt;bucket, 3);        }        return $this;    }    /**    * 把桶里面的水清除掉    */    public function flushWater()    {        unset($this-&gt;bucket[&#39;water&#39;]);        return $this;    }    /**    * 从洗衣桶里面把衣服拿回出来    */    public function fetchCloths()    {        return $this-&gt;bucket[&#39;cloths&#39;]    }}</code></pre><hr><h2 id="提供和调用"><a href="#提供和调用" class="headerlink" title="提供和调用"></a>提供和调用</h2><p>模块与模块或者系统与系统直接都会使用到服务来互相打通业务。这个时候服务就要有一个方式提供出去让外部的模块或者系统调用。</p><blockquote><p><strong>⚠️ 需要注意：</strong><br>这里说的是<code>外部模块</code>或者<code>系统调用</code>，这个是要考虑到如果是微服务的话，每个模块都会在不同的服务器和域名下，这个时候就需要异步调用。这种情况下如果还是用类实例的方式来提供和调用服务后面要改就很麻烦了。</p></blockquote><p>这种情况下目前最优的方式就是服务提供者用<code>Trait</code>给到服务使用者来注入到业务代码里面。</p><ul><li>洗衣机服务Trait - <code>WashingMachineProvider.php</code></li></ul><pre><code class="php">trait WashingMachineProvider{    /**    * 提供洗衣机服务类    */    public washingMachine()    {        return new \WashingMachineService();    }}</code></pre><blockquote><p><strong>⚠️ 需要注意：</strong><br>这里是使用了命名空间来实例洗衣机服务类的。但是如果改成了微服务，那我们只需要改掉所有这些服务提供Trait，把服务类实例改为服务发现，或者异步服务调用就可以了。再也不用花钱去买霸王洗发水了。<code>٩(^ᴗ^)۶</code></p></blockquote><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经历了千辛万苦，无数个失眠的夜晚。终于知道服务到底是什么，应该怎么写，怎么写才是对的。写好服务可以提高代码的维护性，编写的代码也会有更强的逻辑和条理。好的服务也会有更好的弹性和扩张性。下面我们来总结一下编写服务的重点。</p><blockquote><p><code>角色</code>: 服务是系统架构里面的业务处理层。<br><code>作用</code>: 主要是为了高度解耦和封装不同场景的业务和功能到对应的服务，然而达到高度中心化的业务代码。<br><code>思路</code>: 逻辑要独立，分解成逻辑块，保持复用性高，尽量不要限定逻辑使用的顺序和高弹性的组合性。<br><code>编写</code>: 高度封装，高内聚的原理来编写服务，细化分解通用性，公用性的业务，然后封装成一个服务。</p></blockquote><hr><blockquote><p><strong>#通过技术悟出人生道理# 💭</strong><br>  “大千世界每一件事都有千百万种做法，<br>  吸收，打磨，专研，总结，进步，<br>  才会找到最适合的做法。” <small> <em>～ 三·钻 TriDiamond</em><small></small></small></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> BackEnd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Service </tag>
            
            <tag> Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Console技巧提高JS调试技能</title>
      <link href="/2019/10/11/frontend/debugging-skills-console.html"/>
      <url>/2019/10/11/frontend/debugging-skills-console.html</url>
      
        <content type="html"><![CDATA[<p>其实 <strong>JavaScript</strong> 给到我们很多调试工具来调试代码，那问问你自己，你又知道多少呢？用到多少呢？</p><p>大部分前端开发在 <strong>JavaScript</strong> 调试代码的常规用法都是直接<code>console.log</code>，直接输出某一个变量或者返回数据里面的对象数据。当然毋庸置疑这样输出来调试是没有问题的。但是不是最优雅的方式来调试代码，其实还有更好的办法。作为一个有追求的技术人才，有更好的调试方式为什么不去使用呢？</p><p><img src="https://s2.ax1x.com/2019/10/11/ubREy4.png" alt="Console输出Hello"></p><p>我们先来了解清楚浏览器的<code>console</code>。浏览器的<code>console</code>对象有提供自带的调试控制台。<code>console</code>对象只能在浏览器的JavaScript中使用，也就是说客户端应用可用而服务端应用不可用。它的作用或者效果会根据不同的浏览器而不同，但是基础使用方式和功能是基本一致的。不过<code>console</code>是可以在任何前端语言或者框架中使用。</p><hr><h2 id="console-log"><a href="#console-log" class="headerlink" title="console.log"></a>console.log</h2><p>最常用的使用方式就是<code>console.log</code>，对前端开发工程师来说就是家常便饭了。以下是一个简单的使用例子。</p><pre><code class="js">function sayHello(name) {  console.log(name)}sayHello(&#39;Indrek&#39;)</code></pre><blockquote><p>以上<code>sayHello</code>方法接收一个名字，然后在控制台输出出来。</p></blockquote><p><img src="https://s2.ax1x.com/2019/10/12/ujmEr9.png" alt="Console输出名字"></p><p>现在我们开始玩以下更有趣的调试方法。加入我们现在想知道<code>sayHello</code>这个方法被调用了多少次，这样我们应该怎么调试呢？其实有一个很简单的办法就是使用<code>console.count()</code>.</p><hr><h2 id="console-count"><a href="#console-count" class="headerlink" title="console.count"></a>console.count</h2><p><code>count()</code>方法会输出某一个<code>标示</code>被调用了几次。如果没有穿任何参数，<code>count()</code>默认为使用默认标示<code>defaut</code>。</p><pre><code class="js">function sayHello(name) {  console.count()  console.log(name)}sayHello(&quot;Indrek&quot;)sayHello(&quot;William&quot;)sayHello(&quot;Kelly&quot;) </code></pre><blockquote><p>以上代码就会在控制台输出以下结果：</p></blockquote><p><img src="https://s2.ax1x.com/2019/10/12/ujm7ZR.png" alt="统计了sayHello方法被调用的次数"></p><p>上面的例子实现了统计某一个方法被调用的次数，那如果我们想统计每个同名字(<code>name</code>)的在这个方法里面被调用了多少次呢？要调试这种其实也很简单，只要直接吧<code>name</code>直接传入<code>count</code>就可以了。</p><pre><code class="js">function sayHello(name) {  console.count(name)}sayHello(&quot;Indrek&quot;)sayHello(&quot;William&quot;)sayHello(&quot;Kelly&quot;)sayHello(&quot;Indrek&quot;)</code></pre><p><code>‍(∩｀-´)⊃━☆ﾟ.*・｡ﾟ</code> 巴拉巴拉！就是那么简单，我们就可以跟踪同名的参数在<code>sayHello</code>方法里面被调用的次数了！</p><p><img src="https://s2.ax1x.com/2019/10/13/uj1xhR.png" alt="统计同名的参数在`sayHello`方法里面被调用的次数"></p><hr><h2 id="console-warn"><a href="#console-warn" class="headerlink" title="console.warn"></a>console.warn</h2><p>这个控台答应方法会输出一个警告信息。在你开发APIs或者开发工具的时候使用。<code>console.warn</code>这个方法在你需要警告用户的时候特别实用，例如漏掉了某个参数或者是让开发者知道你的API/插件包的版本已经失效的时候使用。</p><pre><code class="js">function sayHello(name) {  if(!name) {    console.warn(&quot;No name given&quot;)  }}sayHello()</code></pre><blockquote><p>上面的代码检测了<code>sayHello</code>方法的参数是否漏传。如果<code>name</code>参数没有传，一个警告消息就会被打印到控制台中。让开发者可以思考问题出在哪里。</p></blockquote><p><img src="https://s2.ax1x.com/2019/10/13/uj85Q0.png" alt="一个警告消息就会被打印到控制台中。让开发者可以思考问题出在哪里"></p><hr><h2 id="console-table"><a href="#console-table" class="headerlink" title="console.table"></a>console.table</h2><p>如果是我们在调试数组或者对象时，<code>console.table</code>是一个非常实用的调试方法来在控制台打印数据。数组里面的每一个元素都会在表格的行里面展示。以下是的水果名数组作为一个例子，如果我们把这个数组传入<code>console.table</code>，我们会看到一个含有这个水果名数据以表格的方式在控制台被打印出来。</p><pre><code class="js">const fruits = [&quot;kiwi&quot;, &quot;banana&quot;, &quot;strawberry&quot;]console.table(fruits)</code></pre><blockquote><p>我们一起来围观以下在控制台里面的展示效果</p></blockquote><p><img src="https://s2.ax1x.com/2019/10/13/ujGlkQ.png" alt="数据以表格的形式打印在控制台"></p><p>看到了这个，你会不会灵光一闪想到mmp，如果是一个很大的数组这种表格化的展示方式是多么的实用啊！对的！例如一个上百个数据的数组，我们使用这种调试方法来打印就很方便了。为了可以让我们用双眼见证这个说法的真实性，我们用代码说话吧！</p><pre><code class="js">const fruits = [  &quot;Apple&quot;,  &quot;Watermelon&quot;,  &quot;Orange&quot;,  &quot;Pear&quot;,  &quot;Cherry&quot;,  &quot;Strawberry&quot;,  &quot;Nectarine&quot;,  &quot;Grape&quot;,  &quot;Mango&quot;,  &quot;Blueberry&quot;,  &quot;Pomegranate&quot;,  &quot;Carambola&quot;,  &quot;Plum&quot;,  &quot;Banana&quot;,  &quot;Raspberry&quot;,  &quot;Mandarin&quot;,  &quot;Jackfruit&quot;,  &quot;Papaya&quot;,  &quot;Kiwi&quot;,  &quot;Pineapple&quot;,  &quot;Lime&quot;,  &quot;Lemon&quot;,  &quot;Apricot&quot;,  &quot;Grapefruit&quot;,  &quot;Melon&quot;,  &quot;Coconut&quot;,  &quot;Avocado&quot;,  &quot;Peach&quot;];console.table(fruits);</code></pre><p>我们使用<code>console.table</code>来打印一下上面这个大数组试试看吧。</p><p><img src="https://s2.ax1x.com/2019/10/13/ujGvNQ.png" alt="使用表格化方式在控制台打印数据"></p><blockquote><p>这种展示方式简直就是一目了然！这样妈妈再也不用担心我们调试数据的时候蒙圈了！<code>՞༘✡ (๑ •̀ㅂ•́)و✧</code></p></blockquote><p>但是问题少年们，我们可是有梦想的工程师，如果是用来调试<code>对象</code>会是怎么样呢？来吧亲自动手丰衣足食，上代码！</p><pre><code class="js">const pets = {  name: &quot;Simon&quot;,  type: &quot;cat&quot;};console.table(pets);</code></pre><p>注意了兄弟姐妹们，现在我们打印的是对象不是数组。在控制台的表格现在有两个键值<code>name</code>和<code>type</code>。之前是0，1，2，3，4…</p><p><img src="https://s2.ax1x.com/2019/10/13/ujtOHK.png" alt="控制台表格化打印对象数据"></p><p>这种方式可以替代普遍使用的直接用log打印对象数据，表格化的展示相对还是更加清晰的。问题少年再次发问，如果我们想多个对象一起打印呢？</p><pre><code class="js">const pets = {  name: &quot;Simon&quot;,  type: &quot;cat&quot;};const person = {  firstName: &quot;Indrek&quot;,  lastName: &quot;Lasn&quot;}console.table(pets, person);</code></pre><p>与预想一致，两个不同键值的对象被才分成两个表格在控制台打印出来了。</p><p><img src="https://s2.ax1x.com/2019/10/13/ujNQuq.png" alt="两个对象一起打印"></p><p>如果我们不想分开两个表格打印，可否在一个表格显示呢？可以的！只要把两个对象放入一个数组就ok了。</p><pre><code class="js">const pets = {  name: &quot;Simon&quot;,  type: &quot;cat&quot;};const person = {  firstName: &quot;Indrek&quot;,  lastName: &quot;Lasn&quot;}console.table([pets, person]);</code></pre><p>现在我们看到两个对象在一个表格里面展示了，键值被放在表格的头部了，因为键值在两个对象里面是不一样的。</p><p><img src="https://s2.ax1x.com/2019/10/13/ujNtC4.png" alt="两个对象在一个表格里面打印"></p><hr><h2 id="console-group"><a href="#console-group" class="headerlink" title="console.group"></a>console.group</h2><p>当我们是在调试集合（sets）或者是关联数据（linked-data），可以使用嵌套组来优化你的控制台输出。使用<code>console.group()</code>来创建一个嵌套的组。</p><pre><code class="js">console.log(&quot;This is the first level&quot;);console.group();console.log(&quot;Level 2&quot;);console.group();console.log(&quot;Level 3&quot;);console.warn(&quot;More of level 3&quot;);console.groupEnd();console.log(&quot;Back to level 2&quot;);console.groupEnd();console.log(&quot;Back to the first level&quot;);</code></pre><p>以下是一个嵌套的层级提示输出，在调试关联或者层级数据的时候特别实用。</p><p><img src="https://s2.ax1x.com/2019/10/13/ujNy5D.png" alt></p><blockquote><p>使用<code>console.groupCollapsed()</code>可以把所有嵌套的层级收起来，使用鼠标点击时可以展开查看。</p></blockquote><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>作为一名优秀的程序员，我们应该尽量在合适的场景或者合适的情况下运用在提供到给我的调试工具。所以这一篇文章提到的调试方式，我们应该在开发调试的过程中多合理运用，习惯后我们会发现调试起来会更加敏捷和高效。</p><hr><blockquote><p><strong>#通过技术悟出人生道理# 💭</strong><br>“人生无常，写的了一行是一行<br>Code now or never” <small> <em>～ 三·钻 TriDiamond</em> <small></small></small></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> FrontEnd </category>
          
          <category> Tips </category>
          
          <category> Debugging </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Console </tag>
            
            <tag> Debugging </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitLab Webhook 自动部署</title>
      <link href="/2019/09/10/server/aliyun-webhook-setup.html"/>
      <url>/2019/09/10/server/aliyun-webhook-setup.html</url>
      
        <content type="html"><![CDATA[<h2 id="创建与填写部署公钥"><a href="#创建与填写部署公钥" class="headerlink" title="创建与填写部署公钥"></a>创建与填写部署公钥</h2><h3 id="创建部署公钥"><a href="#创建部署公钥" class="headerlink" title="创建部署公钥"></a>创建部署公钥</h3><pre><code class="bash">sudo -Hu www ssh-keygen -t rsa</code></pre><blockquote><p>如果创建失败首先需要创建/home/www/.ssh这个文件夹</p></blockquote><h3 id="查看公钥"><a href="#查看公钥" class="headerlink" title="查看公钥"></a>查看公钥</h3><pre><code class="bash">cat /home/www/.ssh/id_rsa.pub</code></pre><h3 id="添加Hook"><a href="#添加Hook" class="headerlink" title="添加Hook"></a>添加Hook</h3><p>在阿里云code.aliyun.com上的profile&gt;ssh_key里面添加公钥</p><h2 id="初始化git项目文件夹"><a href="#初始化git项目文件夹" class="headerlink" title="初始化git项目文件夹"></a>初始化git项目文件夹</h2><pre><code class="bash">sudo -Hu www git clone [git地址]</code></pre><blockquote><p>这里注意, 一定要用www的身份状态要不后期无法自动git pull</p></blockquote><h2 id="自动部署脚本-PHP"><a href="#自动部署脚本-PHP" class="headerlink" title="自动部署脚本 (PHP)"></a>自动部署脚本 (PHP)</h2><h3 id="Shell-exec"><a href="#Shell-exec" class="headerlink" title="Shell_exec"></a>Shell_exec</h3><p>在使用这个PHP脚本的时候我们需要用到<code>shell_exec</code>php的原生函数, php-fpm是默认屏蔽这个函数的, 所有需要在php.ini里面修改一下配置</p><blockquote><p>找到<code>disable_functions</code>这个参数, 并且在里面去掉<code>shell_exec</code></p></blockquote><h3 id="PHP-脚本"><a href="#PHP-脚本" class="headerlink" title="PHP 脚本"></a>PHP 脚本</h3><pre><code class="php">$token = &#39;token&#39;;if (!isset($_GET[&#39;token&#39;]) &amp;&amp; $_GET[&#39;token&#39;] != $token) {    die(&#39;access denied&#39;);}$json = json_decode(file_get_contents(&#39;php://input&#39;), true);$repo = $json[&#39;repository&#39;][&#39;name&#39;];// 只在主分支提交时且提交数大于0执行自动部署if ($json[&#39;ref&#39;]==&#39;refs/heads/master&#39; &amp;&amp; $json[&#39;total_commits_count&#39;]&gt;0) {    $pull_result = shell_exec(&#39;cd /to/project/path/ &amp;&amp; git pull&#39;);    if ($pull_result) {        $res_log = &#39;----------pull 成功---------------&#39;.PHP_EOL;        $res_log .= $json[&#39;user_name&#39;] . &#39; 在&#39; . date(&#39;Y-m-d H:i:s&#39;) . &#39;向&#39; . $json[&#39;repository&#39;][&#39;name&#39;] . &#39;项目的&#39; . $json[&#39;ref&#39;] . &#39;分支push了&#39; . $json[&#39;total_commits_count&#39;] . &#39;个commit：&#39; . PHP_EOL;        $res_log .= $pull_result.PHP_EOL;        file_put_contents(&quot;cityconcierge-webhook-log.txt&quot;, $res_log, FILE_APPEND);//追加写入    } else {        $res_log = &#39;------------pull 失败-------------&#39;.PHP_EOL;        $res_log .= $json[&#39;user_name&#39;] . &#39; 在&#39; . date(&#39;Y-m-d H:i:s&#39;) . &#39;向&#39; . $json[&#39;repository&#39;][&#39;name&#39;] . &#39;项目的&#39; . $json[&#39;ref&#39;] . &#39;分支push了&#39; . $json[&#39;total_commits_count&#39;] . &#39;个commit：&#39; . PHP_EOL;        $res_log .= $pull_result.PHP_EOL;        file_put_contents(&quot;cityconcierge-webhook-log.txt&quot;, $res_log, FILE_APPEND);//追加写入    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gitlab </tag>
            
            <tag> Webhook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lumen 使用 laravel passport</title>
      <link href="/2019/01/10/laravel/lumen-passport-usage.html"/>
      <url>/2019/01/10/laravel/lumen-passport-usage.html</url>
      
        <content type="html"><![CDATA[<p>Lumen是laravel的简洁版, 把laravel里面深重的依赖都去掉了, 所以直接安装laravel的passport是无法正常使用的.<br>所以如果要在lumen上使用laravel的passport就需要安装另外一个插件.</p><h2 id="安装要求"><a href="#安装要求" class="headerlink" title="安装要求"></a>安装要求</h2><ul><li>PHP &gt;= 5.6.3</li><li>Lumen &gt;= 5.3</li></ul><h2 id="Composer安装lumen-passport插件"><a href="#Composer安装lumen-passport插件" class="headerlink" title="Composer安装lumen-passport插件"></a>Composer安装lumen-passport插件</h2><p>首先安装 Lumen Passport</p><pre><code class="bash"># 进入项目根目录$ cd lumen-app# 使用composer安装插件$ composer require dusterio/lumen-passport</code></pre><h2 id="修改-bootstrap-bootstrap-app-php"><a href="#修改-bootstrap-bootstrap-app-php" class="headerlink" title="修改 bootstrap (bootstrap/app.php)"></a>修改 bootstrap (bootstrap/app.php)</h2><p>需要引入Laravel Passport的provider和Lumen的一些provider</p><pre><code class="php">// 开启 Facades$app-&gt;withFacades();// 开启 Eloquent$app-&gt;withEloquent();// 开启 auth 中间件$app-&gt;routeMiddleware([    &#39;auth&#39; =&gt; App\Http\Middleware\Authenticate::class,]);// 注册laravel passport的provider和lumen passport的provider$app-&gt;register(Laravel\Passport\PassportServiceProvider::class);$app-&gt;register(Dusterio\LumenPassport\PassportServiceProvider::class);</code></pre><h2 id="数据表移植和安装Laravel-Passport"><a href="#数据表移植和安装Laravel-Passport" class="headerlink" title="数据表移植和安装Laravel Passport"></a>数据表移植和安装Laravel Passport</h2><pre><code class="bash"># 移植passport的数据表php artisan migrate# 安装passport需要的配置php artisan passport:install</code></pre><h2 id="Lumen-Passport自带的路由"><a href="#Lumen-Passport自带的路由" class="headerlink" title="Lumen Passport自带的路由"></a>Lumen Passport自带的路由</h2><p>这个lumen-passport包已经引入了一下路由, 但是与web相关的路由因为lumen是没有web的路由的, 只有api的, 所以这个插件已经把web端的路由都去掉了.</p><table><thead><tr><th>Verb</th><th>Path</th><th>NamedRoute</th><th>Controller</th><th>Action</th><th>Middleware</th></tr></thead><tbody><tr><td>POST</td><td>/oauth/token</td><td></td><td>\Laravel\Passport\Http\Controllers\AccessTokenController</td><td>issueToken</td><td>-</td></tr><tr><td>GET</td><td>/oauth/tokens</td><td></td><td>\Laravel\Passport\Http\Controllers\AuthorizedAccessTokenController</td><td>forUser</td><td>auth</td></tr><tr><td>DELETE</td><td>/oauth/tokens/{token_id}</td><td></td><td>\Laravel\Passport\Http\Controllers\AuthorizedAccessTokenController</td><td>destroy</td><td>auth</td></tr><tr><td>POST</td><td>/oauth/token/refresh</td><td></td><td>\Laravel\Passport\Http\Controllers\TransientTokenController</td><td>refresh</td><td>auth</td></tr><tr><td>GET</td><td>/oauth/clients</td><td></td><td>\Laravel\Passport\Http\Controllers\ClientController</td><td>forUser</td><td>auth</td></tr><tr><td>POST</td><td>/oauth/clients</td><td></td><td>\Laravel\Passport\Http\Controllers\ClientController</td><td>store</td><td>auth</td></tr><tr><td>PUT</td><td>/oauth/clients/{client_id}</td><td></td><td>\Laravel\Passport\Http\Controllers\ClientController</td><td>update</td><td>auth</td></tr><tr><td>DELETE</td><td>/oauth/clients/{client_id}</td><td></td><td>\Laravel\Passport\Http\Controllers\ClientController</td><td>destroy</td><td>auth</td></tr><tr><td>GET</td><td>/oauth/scopes</td><td></td><td>\Laravel\Passport\Http\Controllers\ScopeController</td><td>all</td><td>auth</td></tr><tr><td>GET</td><td>/oauth/personal-access-tokens</td><td></td><td>\Laravel\Passport\Http\Controllers\PersonalAccessTokenController</td><td>forUser</td><td>auth</td></tr><tr><td>POST</td><td>/oauth/personal-access-tokens</td><td></td><td>\Laravel\Passport\Http\Controllers\PersonalAccessTokenController</td><td>store</td><td>auth</td></tr><tr><td>DELETE</td><td>/oauth/personal-access-tokens/{token_id}</td><td></td><td>\Laravel\Passport\Http\Controllers\PersonalAccessTokenController</td><td>destroy</td><td>auth</td></tr></tbody></table><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>修改 <code>config/auth.php</code> 里面的配置, 按照项目需要修改. 下面是一个简单的例子</p><pre><code class="php">return [    &#39;defaults&#39; =&gt; [        &#39;guard&#39; =&gt; &#39;api&#39;,        &#39;passwords&#39; =&gt; &#39;users&#39;,    ],    &#39;guards&#39; =&gt; [        &#39;api&#39; =&gt; [            &#39;driver&#39; =&gt; &#39;passport&#39;,            &#39;provider&#39; =&gt; &#39;users&#39;,        ],    ],    &#39;providers&#39; =&gt; [        &#39;users&#39; =&gt; [            &#39;driver&#39; =&gt; &#39;eloquent&#39;,            &#39;model&#39; =&gt; \App\User::class        ]    ]];</code></pre><p>需要在 <code>vendor\laravel\lumen-framework\config\auth.php</code> 复制到项目根目录下的<code>config</code>文件夹里面, 如果没有config文件夹, 需要手动添加一个.</p><p>然后在<code>bootstrap/app.php</code>最前面加入配置应用, 因为lumen是不自动引入config里面的配置的.</p><pre><code class="php">$app-&gt;configure(&#39;auth&#39;);</code></pre><h2 id="注册路由"><a href="#注册路由" class="headerlink" title="注册路由"></a>注册路由</h2><p>需要在<code>Provider\AuthServiceProviders.php</code>里面的<code>boot</code>方法里面注册路由</p><pre><code class="php">/*** Boot the authentication services for the application.** @return void*/public function boot(){    // Here you may define how you wish users to be authenticated for your Lumen    // application. The callback which receives the incoming request instance    // should return either a User instance or null. You&#39;re free to obtain    // the User instance via an API token or any other method necessary.    LumenPassport::routes($this-&gt;app); // 注册路由    LumenPassport::tokensExpireIn(Carbon::now()-&gt;addDays(7));    LumenPassport::refreshTokensExpireIn(Carbon::now()-&gt;addDays(30));}</code></pre><p>简单路由注册</p><pre><code class="php">Dusterio\LumenPassport\LumenPassport::routes($this-&gt;app);</code></pre><p>通用版本控制的路由</p><pre><code class="php">Dusterio\LumenPassport\LumenPassport::routes($this-&gt;app, [&#39;prefix&#39; =&gt; &#39;v1/oauth&#39;]);</code></pre><h2 id="用户模型"><a href="#用户模型" class="headerlink" title="用户模型"></a>用户模型</h2><p>需要在用户模型里面加入<code>HasApiTokens</code>的trait, 例子:</p><pre><code class="php">class User extends Model implements AuthenticatableContract, AuthorizableContract{    use HasApiTokens, Authenticatable, Authorizable;    /* rest of the model */}</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>其他的详细文档可以查看lumen-passport的插件<a href="https://github.com/dusterio/lumen-passport" target="_blank" rel="noopener">github</a></p>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel Passport </tag>
            
            <tag> Lumen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lumen passport实现多个用户体系下的oauth验证</title>
      <link href="/2019/01/10/laravel/lumen-multi-oauth.html"/>
      <url>/2019/01/10/laravel/lumen-multi-oauth.html</url>
      
        <content type="html"><![CDATA[<p>这个教程是基于, lumen里面已经安装好了lumen-passport的插件, 如果还没有的话可以先到<a href="/2019/01/10/2019-01-10-lumen-passport-usage/">lumen使用laravel passport教程</a>先安装.</p><h2 id="改写Laravel-Passport里面的UserRepository"><a href="#改写Laravel-Passport里面的UserRepository" class="headerlink" title="改写Laravel Passport里面的UserRepository"></a>改写Laravel Passport里面的<code>UserRepository</code></h2><blockquote><p>文件路径 <code>vendor\laravel\passport\src\Bridge\UserRepository.php</code></p></blockquote><ul><li><p>首先需要改写<code>userRepositroy</code>里面的<code>getUserEntityByUserCredentials</code>方法</p></li><li><p>复制<code>userRepositroy</code>里面的<code>getUserEntityByUserCredentials</code>方法, 改名为<code>getEntityByUserCredentials</code></p></li><li><p>在新建的方法里面找到一下代码</p></li></ul><pre><code class="php">$provider = config(&#39;auth.guards.api.provider&#39;);</code></pre><p>改成一下样子</p><pre><code class="php">$provider = config(&#39;auth.guards.&#39;.$provider.&#39;.provider&#39;);</code></pre><ul><li>然后在新的方法<code>getEntityByUserCredentials</code>的参数里面添加新的参数<code>$provider</code></li></ul><pre><code class="php">public function getEntityByUserCredentials($username, $password, $grantType,   ClientEntityInterface $clientEntity, $provider) {      //...}</code></pre><h2 id="修改oauth2-server里面的PasswordGrand"><a href="#修改oauth2-server里面的PasswordGrand" class="headerlink" title="修改oauth2-server里面的PasswordGrand"></a>修改oauth2-server里面的PasswordGrand</h2><blockquote><p>文件路径 <code>vendor\league\oauth2-server\src\Grant\PasswordGrant.php</code></p></blockquote><ul><li>修改<code>validateUser</code>方法里面的这一串代码:</li></ul><pre><code class="php">$user = $this-&gt;userRepository-&gt;getEntityByUserCredentials(    $username,    $password,    $this-&gt;getIdentifier(),    $client,    $provider // 新加的provider字段);</code></pre><ul><li>在同一个方法里面加入新参数的获取</li></ul><pre><code class="php"> $provider = $this-&gt;getRequestParameter(&#39;provider&#39;, $request); if (is_null($provider)) { throw OAuthServerException::invalidRequest(&#39;provider&#39;); }</code></pre><h2 id="在auth-php配置里面加入新的guard"><a href="#在auth-php配置里面加入新的guard" class="headerlink" title="在auth.php配置里面加入新的guard"></a>在auth.php配置里面加入新的guard</h2><p>首先需要加入新的guard配置</p><pre><code class="php">&#39;guards&#39; =&gt; [    // 原有的api guard    &#39;api&#39; =&gt; [        &#39;driver&#39; =&gt; &#39;passport&#39;,        &#39;provider&#39; =&gt; &#39;users&#39;,    ],    // 新加的admin-api guard    &#39;admin-api&#39; =&gt; [        &#39;driver&#39; =&gt; &#39;passport&#39;,        &#39;provider&#39; =&gt; &#39;admins&#39;,    ],],</code></pre><p>添加新<code>admin-api</code> guard的provider</p><pre><code class="php">&#39;providers&#39; =&gt; [    &#39;users&#39; =&gt; [        &#39;driver&#39; =&gt; &#39;eloquent&#39;,        &#39;model&#39; =&gt; \App\Models\General\MemberLogin::class    ],    // 新加的admins provider对应不用的用户模型    &#39;admins&#39; =&gt; [        &#39;driver&#39; =&gt; &#39;eloquent&#39;,        &#39;model&#39; =&gt; \App\Models\Backend\Manager::class    ]],</code></pre><h2 id="路由middleware使用"><a href="#路由middleware使用" class="headerlink" title="路由middleware使用"></a>路由middleware使用</h2><p>区别在于middleware, 上文加入的新<code>admin-api</code>guard, 在新的路由里面就可以使用<code>auth:admin-api</code>的权限验证中间件理实现权限控制了!</p><pre><code class="php">/*|--------------------------------------------------------------------------| Admin API版本 v1 路由|--------------------------------------------------------------------------.|| prefix admin/api/api版本号| namespace Api\api版本号|*/$app-&gt;group([&#39;prefix&#39; =&gt; &#39;admin/api/v1&#39;, &#39;namespace&#39; =&gt; &#39;AdminApi\V1&#39;], function ($app) {    // ================ 不受登录权限控制的接口路由 ================ //    //测试    $app-&gt;get(&#39;test&#39;, &#39;ExampleController@test&#39;);    // ================ 受登录权限控制的接口路由 ================ //    $app-&gt;group([&#39;middleware&#39; =&gt; &#39;auth:admin-api&#39;], function ($app) {        //测试        $app-&gt;get(&#39;test2&#39;, function(){            return &#39;oauth test&#39;;        });        //测试        $app-&gt;get(&#39;test3&#39;, &#39;ExampleController@test&#39;);    });});</code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>使用了多个guard的时候, 在使用laravel默认的<code>$request-&gt;user()</code>, 这个方法默认是使用<code>api</code>guard的, 可以在<code>auth.php</code>配置里面看到默认guard的配置.</p><pre><code class="php">/*|--------------------------------------------------------------------------| Authentication Defaults|--------------------------------------------------------------------------|| This option controls the default authentication &quot;guard&quot; and password| reset options for your application. You may change these defaults| as required, but they&#39;re a perfect start for most applications.|*/&#39;defaults&#39; =&gt; [    &#39;guard&#39; =&gt; env(&#39;AUTH_GUARD&#39;, &#39;api&#39;),    &#39;passwords&#39; =&gt; &#39;users&#39;,],</code></pre><p>所以在使用新的<code>admin-api</code> guard的时候在使用<code>$request-&gt;user()</code>时需要加入对应的guard. 例子:</p><pre><code class="php">namespace App\Http\Controllers\AdminApi\V1;use App\Http\Controllers\Controller;use Illuminate\Http\Request;use Illuminate\Support\Facades\Cache;class ExampleController extends Controller{    public function test(Request $request)    {        $request-&gt;user(&#39;admin-api&#39;)-&gt;toArray(); // 获取到admin-api下的用户信息    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel Passport </tag>
            
            <tag> Lumen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IONIC 2 实现首页双击退出APP</title>
      <link href="/2017/04/24/ionic/listen-to-back-button.html"/>
      <url>/2017/04/24/ionic/listen-to-back-button.html</url>
      
        <content type="html"><![CDATA[<h2 id="添加绑定值"><a href="#添加绑定值" class="headerlink" title="添加绑定值"></a>添加绑定值</h2><blockquote><p>首先在<code>app/app.html</code>下加入<code>#myNav</code>, 这个是用于绑定当前页面的导航标签</p></blockquote><pre><code class="html"> &lt;ion-nav #myNav [root]=&quot;rootPage&quot;&gt;&lt;/ion-nav&gt;</code></pre><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><blockquote><p>然后在<code>app.component.ts</code>做相对的改动</p></blockquote><pre><code class="ts">import { Component, ViewChild } from &#39;@angular/core&#39;;import { Platform, ToastController, Nav, App } from &#39;ionic-angular&#39;;import { StatusBar } from &#39;@ionic-native/status-bar&#39;;import { SplashScreen } from &#39;@ionic-native/splash-screen&#39;;@Component({  templateUrl: &#39;app.html&#39;,  providers: [SplashScreen, StatusBar]})export class MyApp {  rootPage = &#39;TabsPage&#39;;  backButtonPressed: boolean = false;  //用于判断返回键是否触发  @ViewChild(&#39;myNav&#39;) nav: Nav;  constructor(public platform: Platform, private splashScreen: SplashScreen, private statusBar: StatusBar, public app: App, public toastCtrl: ToastController) {    platform.ready().then(() =&gt; {      // Okay, so the platform is ready and our plugins are available.      // Here you can do any higher level native things you might need.      this.statusBar.styleDefault();      this.statusBar.backgroundColorByHexString(&#39;#661F22&#39;);      this.splashScreen.hide();      this.registerBackButtonAction(); //运行这个方法绑定返回按钮    });  }  registerBackButtonAction() {    this.platform.registerBackButtonAction(() =&gt; {      //如果想点击返回按钮隐藏toast或loading或Overlay就把下面加上      // this.ionicApp._toastPortal.getActive() || this.ionicApp._loadingPortal.getActive() || this.ionicApp._overlayPortal.getActive();      let nav = this.app.getActiveNav();      if (nav.canGoBack()){ //是否已经到了首页        nav.pop();      }else{        this.showExit()      }    }, 1);  }  //双击退出提示框  showExit() {    if (this.backButtonPressed) { //当触发标志为true时，即2秒内双击返回按键则退出APP      this.platform.exitApp();    } else {     this.toastCtrl.create({      message: &#39;再按一次退出应用&#39;,      duration: 2000,      position: &#39;middle&#39;     }).present();     this.backButtonPressed = true;     setTimeout(() =&gt; this.backButtonPressed = false, 2000);//2秒内没有再次点击返回则将触发标志标记为false    }  }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Ionic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ionic 2 </tag>
            
            <tag> Hybird App </tag>
            
            <tag> Angular 4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IONIC 3 使用sliders轮播时拖动后autoplay失效解决方法</title>
      <link href="/2017/04/20/ionic/sliders-autoplay.html"/>
      <url>/2017/04/20/ionic/sliders-autoplay.html</url>
      
        <content type="html"><![CDATA[<h4 id="我们先了解一下Ionic的Sliders"><a href="#我们先了解一下Ionic的Sliders" class="headerlink" title="我们先了解一下Ionic的Sliders"></a>我们先了解一下Ionic的Sliders</h4><blockquote><p>首先Ionic里面的sliders是用<a href="http://idangero.us/swiper/api/#.WPhzbPB96Uk" target="_blank" rel="noopener">Swiper.js</a>的第三方插件实现的, Ionic官方Sliders的文档里面只描述了可以直接写入html标签内的属性, 有很多高级属性是没有写在文档里面的. </p></blockquote><h4 id="要怎么改变sliders的其他属性呢"><a href="#要怎么改变sliders的其他属性呢" class="headerlink" title="要怎么改变sliders的其他属性呢?"></a>要怎么改变sliders的其他属性呢?</h4><blockquote><p>那如果我们要用到Swiper的其他属性怎么办呢? Ionic 2.x 的时候我们是可以在options里面传入的, 但是升级Ionic 3.x.x 后sliders的options属性被移除了. 现在要改变sliders的属性我们要用到sliders类. </p></blockquote><h4 id="如何拖动轮播图后不让autoplay失效呢"><a href="#如何拖动轮播图后不让autoplay失效呢" class="headerlink" title="如何拖动轮播图后不让autoplay失效呢?"></a>如何拖动轮播图后不让autoplay失效呢?</h4><blockquote><p>首先我们要引入<code>viewChild</code>和<code>Sliders</code></p></blockquote><pre><code class="ts">import { ViewChild } from &#39;@angular/core&#39;;import { Slides } from &#39;ionic-angular&#39;;</code></pre><blockquote><p>然后使用<code>ionViewWillEnter</code>在进入页面前改变sliders的<code>autoplayDisableOnInteraction</code>属性</p></blockquote><pre><code class="ts">import { ViewChild } from &#39;@angular/core&#39;;import { Slides } from &#39;ionic-angular&#39;;class MyPage {  @ViewChild(Slides) slides: Slides;  ionViewWillEnter() {    this.slides.autoplayDisableOnInteraction = false; //禁止slider拖动后autoPlay失效  }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Ionic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hybird App </tag>
            
            <tag> Angular 4 </tag>
            
            <tag> Ionic 3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修复 Ionic 3.0.1 在IOS点击Tabs多次出现黑屏问题方法</title>
      <link href="/2017/04/11/ionic/ios-blackscreen-fix.html"/>
      <url>/2017/04/11/ionic/ios-blackscreen-fix.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Ionic 3.0.1 在IOS存在的一个严重的BUG，在IOS下多次重复点击TAB的时候页面会出现黑屏问题。</p></blockquote><blockquote><p>好消息是目前有一个暂时的修复方法。但是这个方法涉及修改Ionic核心代码，所以如果你们正在使用Ionic3发布APP，可以暂时使用以下办法修复问题。</p></blockquote><blockquote><p>在<code>node_modules/ionic-angular/components/tabs/tabs.js</code>找到一下代码 (468行)</p></blockquote><pre><code class="typescript">getComponent(this._linker, tab.root).then(function (viewController) {    if (viewController !== active.component) {        // Otherwise, if the page we&#39;re on is not our real root        // reset it to our default root type        return tab.setRoot(tab.root);    }}).catch(function () {    (void 0) /* console.debug */;});</code></pre><blockquote><p>把以上代码改为</p></blockquote><pre><code class="typescript">getComponent(this._linker, tab.root).then(function (viewController) {    if (viewController.component !== active.component) {        // Otherwise, if the page we&#39;re on is not our real root        // reset it to our default root type        return tab.setRoot(tab.root);    }}).catch(function () {    (void 0) /* console.debug */;});</code></pre><blockquote><p>以上解决办法来自于github上面的一个大神 <a href="https://github.com/driftyco/ionic/pull/11084" target="_blank" rel="noopener">https://github.com/driftyco/ionic/pull/11084</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Ionic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hybird App </tag>
            
            <tag> Angular 4 </tag>
            
            <tag> Ionic 3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IONIC 2 升级 3 教程</title>
      <link href="/2017/04/10/ionic/upgrade-guide.html"/>
      <url>/2017/04/10/ionic/upgrade-guide.html</url>
      
        <content type="html"><![CDATA[<h2 id="升级步骤"><a href="#升级步骤" class="headerlink" title="升级步骤"></a>升级步骤</h2><blockquote><p>这一次的升级Ionic 3 换成了使用最新的Angular 4.0, 最新的TypeScript, 添加了懒加载和修复了一些组件的bug.</p></blockquote><ol><li>首先更新<code>package.json</code>, 按照以下的代码相应替换你package.json里面的代码, 并且把你项目根目录下的<code>node_modules</code>文件夹删除掉, 然后运行<code>npm install</code> (如果你是用淘宝镜像可以运行 <code>cnpm install</code>)</li></ol><pre><code class="json">&quot;dependencies&quot;: {    &quot;@angular/common&quot;: &quot;4.0.0&quot;,    &quot;@angular/compiler&quot;: &quot;4.0.0&quot;,    &quot;@angular/compiler-cli&quot;: &quot;4.0.0&quot;,    &quot;@angular/core&quot;: &quot;4.0.0&quot;,    &quot;@angular/forms&quot;: &quot;4.0.0&quot;,    &quot;@angular/http&quot;: &quot;4.0.0&quot;,    &quot;@angular/platform-browser&quot;: &quot;4.0.0&quot;,    &quot;@angular/platform-browser-dynamic&quot;: &quot;4.0.0&quot;,    &quot;@ionic-native/core&quot;: &quot;3.4.2&quot;,    &quot;@ionic-native/splash-screen&quot;: &quot;3.4.2&quot;,    &quot;@ionic-native/status-bar&quot;: &quot;3.4.2&quot;,    &quot;@ionic/storage&quot;: &quot;2.0.1&quot;,    &quot;ionic-angular&quot;: &quot;3.0.1&quot;,    &quot;ionicons&quot;: &quot;3.0.0&quot;,    &quot;rxjs&quot;: &quot;5.1.1&quot;,    &quot;sw-toolbox&quot;: &quot;3.4.0&quot;,    &quot;zone.js&quot;: &quot;^0.8.4&quot;},&quot;devDependencies&quot;: {  &quot;@ionic/app-scripts&quot;: &quot;1.3.0&quot;,  &quot;typescript&quot;: &quot;~2.2.1&quot;}</code></pre><ol start="2"><li>第二步你需要在<code>app/app.module.ts</code>文件里面引入<code>BrowserModule</code>和<code>HttpModule</code></li></ol><blockquote><p>首先需要在头部引入这两个module (如果你的APP不使用HTTP可以不引入<code>HttpModule</code>)</p></blockquote><pre><code class="typescript">import { BrowserModule } from &#39;@angular/platform-browser&#39;;import { HttpModule } from &#39;@angular/http&#39;;</code></pre><blockquote><p>在同一个文件里面找到<code>imports</code>并且加入<code>BrowserModule</code>和<code>HttpModule</code></p></blockquote><pre><code class="typescript">imports: [  BrowserModule,  HttpModule,  IonicModule.forRoot(MyApp)],</code></pre><ol start="3"><li>如果你升级到 Ionic Native 3.x, 就是CLI3. 使用 Ionic Native 3.x的话, APP打包出来会更小. 因为Ionic Native的原生插件都不自带有了, 你使用一个就要安装一个. 如果你原有的Ionic 2 项目有引入原生插件, 你就要做以下操作.</li></ol><blockquote><p>这里用<code>Camera</code>和<code>Geolocation</code>这个两个原生插件作为例子, 你其他的插件都需要使用相同的方式做修改</p></blockquote><blockquote><p>注意您使用的所有插件都必须要在<code>app/app.module.ts</code>里面先引用了, 而且要在<code>app/app.modules.ts</code>里面的providers里面声明, 如果没有这样配置就会出现<code>No provider for XXXXX</code>这样的报错了!</p></blockquote><h4 id="Camera插件"><a href="#Camera插件" class="headerlink" title="Camera插件"></a>Camera插件</h4><pre><code class="typescript">// 在app/app.module.ts文件里面import { Camera } from &#39;@ionic-native/camera&#39;;...@NgModule({  ...  providers: [    ...    Camera    ...  ]  ...})export class AppModule { }</code></pre><h4 id="Geolocation插件"><a href="#Geolocation插件" class="headerlink" title="Geolocation插件"></a>Geolocation插件</h4><pre><code class="typescript">// 在app/app.module.ts文件里面import { Geolocation } from &#39;@ionic-native/geolocation&#39;;import { Platform } from &#39;ionic-angular&#39;;import { NgZone } from &#39;@angular/core&#39;;@Component({ ... })export class MyComponent {  constructor(private geolocation: Geolocation, private platform: Platform, private ngZone: NgZone) {    platform.ready().then(() =&gt; {      // get position      geolocation.getCurrentPosition().then(pos =&gt; {        console.log(`lat: ${pos.coords.latitude}, lon: ${pos.coords.longitude}`)      });      // watch position      const watch = geolocation.watchPosition().subscribe(pos =&gt; {        console.log(`lat: ${pos.coords.latitude}, lon: ${pos.coords.longitude}`)        // Currently, observables from Ionic Native plugins        // need to run inside of zone to trigger change detection        ngZone.run(() =&gt; {          this.position = pos;        })      });      // to stop watching      watch.unsubscribe();    });  }}</code></pre><blockquote><p>更详细的文档可以参考官方的修改日记 <a href="https://github.com/driftyco/ionic-native/blob/master/README.md" target="_blank" rel="noopener">https://github.com/driftyco/ionic-native/blob/master/README.md</a></p></blockquote><h2 id="组件Component更变"><a href="#组件Component更变" class="headerlink" title="组件Component更变"></a>组件<code>Component</code>更变</h2><h4 id="新网格"><a href="#新网格" class="headerlink" title="新网格"></a>新网格</h4><blockquote><p>旧的网格体系已经废除, 新的网格组件请参考官方文档 <a href="http://blog.ionic.io/build-awesome-desktop-apps-with-ionics-new-responsive-grid/" target="_blank" rel="noopener">http://blog.ionic.io/build-awesome-desktop-apps-with-ionics-new-responsive-grid/</a></p></blockquote><h4 id="标签的color属性更变"><a href="#标签的color属性更变" class="headerlink" title="标签的color属性更变"></a>标签的<code>color</code>属性更变</h4><blockquote><p>以下标签的<code>color</code>属性在新的版本里面会不起效果了, 现在必须要使用<code>ion-text</code>才会起效果, 详细说明请看官方文档 <a href="http://ionicframework.com/docs/api/components/typography/Typography/" target="_blank" rel="noopener">http://ionicframework.com/docs/api/components/typography/Typography/</a></p></blockquote><pre><code class="css">h1[color], h2[color], h3[color], h4[color], h5[color], h6[color], a[color]:not([ion-button]):not([ion-item]):not([ion-fab]), p[color], span[color], b[color], i[color], strong[color], em[color], small[color], sub[color], sup[color]</code></pre><h4 id="Slides组件更变"><a href="#Slides组件更变" class="headerlink" title="Slides组件更变"></a>Slides组件更变</h4><blockquote><p>以下的Slides属性和方法已经正式在新版本里面移除了</p></blockquote><ul><li>Slides的input的<code>options</code>属性已经废除, 请使用标签的属性;</li><li>Slide的事件<code>ionWillChange</code>方法已经废除, 请使用<code>ionSlideWillChange</code>;</li><li>Slide的事件<code>ionDidChange</code>方法已经废除, 请使用<code>ionSlideDidChange</code>;</li><li>Slide的事件<code>ionDrag</code>方法已经废除, 请使用<code>ionSlideDrag</code>;</li><li>Slides的<code>getSlider()</code>方法已经废除, 请使用<code>ion-slides</code>实例;</li></ul>]]></content>
      
      
      <categories>
          
          <category> Ionic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hybird App </tag>
            
            <tag> Angular 4 </tag>
            
            <tag> Ionic 3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IONIC 2 - 确认密码</title>
      <link href="/2017/03/19/ionic/comfirm-password-validators.html"/>
      <url>/2017/03/19/ionic/comfirm-password-validators.html</url>
      
        <content type="html"><![CDATA[<p>开发过程中一般在注册或者修改密码都要写一个密码确认的表格, 这篇文章就是记录怎么在Ionic2里面使用<strong>FormBuilder</strong>和<strong>Validators</strong>判断密码是否一致.</p><p>首先这篇文章是默认您已经了解怎么使用<strong>Angualr2</strong>的<strong>FormBuilder</strong>和<strong>Validator</strong>, 如果你还没了解这两个类的用法可以前去看<a href="https://ionicframework.com/docs/v2/resources/forms/" target="_blank" rel="noopener">Ionic2的文档</a></p><h1 id="实例一个FormGroup"><a href="#实例一个FormGroup" class="headerlink" title="实例一个FormGroup"></a>实例一个<code>FormGroup</code></h1><blockquote><p>第一步首先我们需要实例了FormBuilder的一个FormGroup</p></blockquote><ul><li>这里我们定义了passwordForm的这个表格里面的input.</li><li>在最后我们加入了自定义认证方法 { validator: AdvanceValidator.matchingPasswords(‘password’, ‘rePassword’) }</li><li>这里我们把password, 和rePassword 传给了 AdvanceValidator 方法, 这里传的是密码和确认密码在FormGroup里面定义的名字.</li><li>现在我们看看这个password.ts怎么写.</li></ul><pre><code class="typescript">import { FormBuilder, Validators, FormGroup } from &#39;@angular/forms&#39;;import { AdvanceValidator } from &#39;../../validators/advance-validator&#39;;@Component({  selector: &#39;page-password&#39;,  templateUrl: &#39;password.html&#39;})//密码修改页export class PasswordPage {  passwordForm: FormGroup;  constructor(private fb: FormBuilder)   {    this.passwordForm = fb.group({        username: [&#39;&#39;, Validators.required],        password: [&#39;&#39;, Validators.compose([Validators.maxLength(30), Validators.minLength(7), Validators.required])],        rePassword: [&#39;&#39;, Validators.compose([Validators.maxLength(30), Validators.minLength(7), Validators.required])],    }, { validator: AdvanceValidator.matchingPasswords(&#39;password&#39;, &#39;rePassword&#39;) });  }}</code></pre><h1 id="创建自定义认证器"><a href="#创建自定义认证器" class="headerlink" title="创建自定义认证器"></a>创建自定义认证器</h1><ul><li>我们首先在项目根目录创建 <strong>validators</strong> 的文件夹</li><li>然后在里面创建 <strong>advance-validators.ts</strong> 的ts文件</li><li>在 <strong>advance-validators.ts</strong> 里面编以下代码</li></ul><pre><code class="typescript">import { FormGroup } from &#39;@angular/forms&#39;;export class AdvanceValidator {    static matchingPasswords(passwordKey: string, rePasswordKey: string) {    return (group: FormGroup) =&gt; {      let password = group.controls[passwordKey]; //获取密码值      let rePassword = group.controls[rePasswordKey]; //获取确认密码值      if(password.value !== rePassword.value) {        //如果密码和确认密码的值不一致就返回给FormBuild rePassword有错误        return rePassword.setErrors({notEquivalent: true})       }    }  }}</code></pre><h1 id="前端表格示例"><a href="#前端表格示例" class="headerlink" title="前端表格示例"></a>前端表格示例</h1><pre><code class="html">&lt;form [formGroup] = &quot;passwordForm&quot;&gt;  &lt;ion-list inset&gt;    &lt;ion-item&gt;      &lt;ion-input type=&quot;tel&quot; placeholder=&quot;用户名&quot; formControlName=&quot;username&quot;&gt;&lt;/ion-input&gt;      &lt;div item-right *ngIf=&quot;!passwordForm.controls.username.valid  &amp;&amp; (passwordForm.controls.username.dirty)&quot;&gt;        &lt;ion-icon name=&quot;alert&quot;&gt;&lt;/ion-icon&gt; 用户名必填      &lt;/div&gt;    &lt;/ion-item&gt;    &lt;ion-item&gt;      &lt;ion-input type=&quot;password&quot; placeholder=&quot;新密码&quot; formControlName=&quot;password&quot;&gt;&lt;/ion-input&gt;      &lt;div item-right *ngIf=&quot;!passwordForm.controls.password.valid  &amp;&amp; (passwordForm.controls.password.dirty)&quot; &gt;        &lt;ion-icon name=&quot;alert&quot;&gt;&lt;/ion-icon&gt; 密码必须7个字以上      &lt;/div&gt;    &lt;/ion-item&gt;    &lt;ion-item&gt;      &lt;ion-input type=&quot;password&quot; placeholder=&quot;确认密码&quot; formControlName=&quot;rePassword&quot;&gt;&lt;/ion-input&gt;      &lt;div item-right *ngIf=&quot;!passwordForm.controls.rePassword.valid  &amp;&amp; (passwordForm.controls.rePassword.dirty)&quot; &gt;        &lt;ion-icon name=&quot;alert&quot;&gt;&lt;/ion-icon&gt; 密码必须一致      &lt;/div&gt;    &lt;/ion-item&gt;  &lt;/ion-list&gt;&lt;/form&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Ionic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ionic 2 </tag>
            
            <tag> Angular 2 </tag>
            
            <tag> Hybird App </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel 5.4 开发笔记</title>
      <link href="/2017/02/26/laravel/laravel5.4-passport-and-authen.html"/>
      <url>/2017/02/26/laravel/laravel5.4-passport-and-authen.html</url>
      
        <content type="html"><![CDATA[<p>Laravel最近出的Laravel5.4新加了挺多功能的, 比起我用了1年的5.1完善多了. 比较吸引我使用最新的5.4的有几点:</p><ul><li>5.4 添加了谷歌内核的浏览器模拟操作</li><li>自带API认证类”PASSPORT”</li><li>路由自动分类, 现有有了Route自己的文件夹然后里面分类好了WEB和API的路由<br>这一篇记录会分享一些我在尝试Laravel 5.4的过程中遇到的问题和经验</li></ul><h2 id="开发记录"><a href="#开发记录" class="headerlink" title="开发记录"></a>开发记录</h2><h3 id="移植-Migrate-用户和API认证表格是出现sql错误"><a href="#移植-Migrate-用户和API认证表格是出现sql错误" class="headerlink" title="移植(Migrate)用户和API认证表格是出现sql错误"></a>移植(Migrate)用户和API认证表格是出现sql错误</h3><pre><code class="console">[Illuminate\Database\QueryException]                                                           SQLSTATE[42000]: Syntax error or access violation: 1071 Specified key was too long; max key     length is 767 bytes (SQL: alter table `users` add unique `users_email_unique`(`email`))   </code></pre><pre><code class="console">[PDOException]                                                                                 SQLSTATE[42000]: Syntax error or access violation: 1071 Specified key was too long; max key     length is 767 bytes  </code></pre><p>解决办法就是在<strong>app/Providers/AppServiceProvider.php</strong>的这个文件里面的<strong>boot</strong>方法里面添加一下代码:</p><pre><code class="php">use Illuminate\Support\Facades\Schema;function boot(){    Schema::defaultStringLength(191);}</code></pre><h3 id="怎么不使用Laravel5-4自带的用户登录字段"><a href="#怎么不使用Laravel5-4自带的用户登录字段" class="headerlink" title="怎么不使用Laravel5.4自带的用户登录字段"></a>怎么不使用Laravel5.4自带的用户登录字段</h3><p>每次使用laravel自带的用户认证体系都会纠结, 怎么不用它自带的email作为用户名!<br>这次适用Laravel5.4 又遇到了这个问题, 而且解决办法和5.1,5.2的不一样了, 因为Laravel的Auth Provider变动了.<br>解决办法就是在自带的<strong>User.php</strong>(用户模型)里面使用<strong>findForPassport</strong>, 参考一下例子:</p><pre><code class="php">class User extends Authenticatable{    use HasApiTokens, Notifiable;    // ... some code    public function findForPassport($username) {        return $this-&gt;where(&#39;id&#39;, $username)-&gt;first();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel 5.4 </tag>
            
            <tag> Laravel Passport </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IONIC 2 开发笔记</title>
      <link href="/2017/02/25/ionic/dev-note.html"/>
      <url>/2017/02/25/ionic/dev-note.html</url>
      
        <content type="html"><![CDATA[<p>因为IONIC2才刚刚开始进入正式版, 中文文档基本都是不全的, 我现在开发都是在看英文文档<br>在开发的过程中遇到了很多文档没有描述的问题, 而且开发的过程中遇到一些框架本身没有完善的功能和存在的BUG</p><p>我会在这个日记里面记录一些文档没有写的, 和我开发过程中遇到的一些坑和经验, 希望可以帮助那些刚刚接触IONIC2的程序猿们!</p><h2 id="APP配置"><a href="#APP配置" class="headerlink" title="APP配置"></a>APP配置</h2><h3 id="域名配置"><a href="#域名配置" class="headerlink" title="域名配置"></a>域名配置</h3><p>因为跨域问题，在开发时如果要用到本地环境进行开发(ionic serve)，必须配置proxy</p><ul><li>Proxy位于项目根目录下的 <strong>ionic.config.json</strong></li></ul><ul><li>只需要把<strong>proxyUrl</strong>改为你本地环境的API地址</li></ul><pre><code class="javascript">{  &quot;name&quot;: &quot;rlph&quot;,  &quot;app_id&quot;: &quot;&quot;,  &quot;v2&quot;: true,  &quot;typescript&quot;: true,  &quot;proxies&quot;: [    {      &quot;path&quot;: &quot;/api&quot;,      &quot;proxyUrl&quot;: &quot;http://api.dev&quot;    }  ]}</code></pre><ul><li>然后把API地址的常量制定为<strong>/api/</strong>这个proxy</li></ul><ul><li>在根目录下<strong>/src/config.ts</strong>里面把<strong>“API_SERVER”</strong>的值改为<strong>“/api/“</strong></li></ul><pre><code>  export let data = {      &quot;API_SERVER&quot; : &quot;/api/&quot;  }</code></pre><h3 id="上线APP配置"><a href="#上线APP配置" class="headerlink" title="上线APP配置"></a>上线APP配置</h3><ul><li>首先你需要配置真是服务器API地址<br>配置API地址是在根目录下<strong>/src/config.ts</strong>里面把<strong>“API_SERVER”</strong>的值改为线上API地址</li></ul><pre><code>  export let data = {      &quot;API_SERVER&quot; : &quot;http://api.domain.com/&quot;  }</code></pre><h2 id="开发常见问题"><a href="#开发常见问题" class="headerlink" title="开发常见问题"></a>开发常见问题</h2><h3 id="APP-run-失败"><a href="#APP-run-失败" class="headerlink" title="APP run 失败"></a>APP run 失败</h3><p>当运行<strong>ionic run android</strong>的时候可能会遇到该报错：</p><pre><code>Error: Failed to install apk to device: [  1%] /data/local/tmp/android-debug.apk[  2%] /data/local/tmp/android-debug.apk...[100%] /data/local/tmp/android-debug.apk        pkg: /data/local/tmp/android-debug.apkFailure [INSTALL_FAILED_UPDATE_INCOMPATIBLE]</code></pre><ul><li>此问题是因为已有签名的APP存在手机上， 需要想删除该APP才能安装测试（debug）版的apk</li><li>在cmd运行以下代码即可解决问题：</li></ul><pre><code>adb uninstall my.package.id</code></pre><h3 id="Ionic-2-自带的native文件上传-FILE-TRANSFER-插件无法获取成功返回内容"><a href="#Ionic-2-自带的native文件上传-FILE-TRANSFER-插件无法获取成功返回内容" class="headerlink" title="Ionic 2 自带的native文件上传(FILE TRANSFER)插件无法获取成功返回内容"></a>Ionic 2 自带的native文件上传(FILE TRANSFER)插件无法获取成功返回内容</h3><p>这个是Ionic 2 核心代码里面的一个BUG, 在一下版本下是有问题的<br><strong>Ionic CLI Version: 2.2.1</strong></p><ul><li>首先找到项目根目录下以下路径里面的<strong>filetransfer.d.ts</strong>文件</li></ul><pre><code>node_modules\ionic-native\dist\es5\plugins\filetransfer.d.tsnode_modules\ionic-native\dist\esm\plugins\filetransfer.d.ts</code></pre><ul><li>分别修改以上两个文件里面的代码</li></ul><pre><code>//把这一行:upload(fileUrl: string, url: string, options?: FileUploadOptions, trustAllHosts?: boolean): Promise&lt;FileUploadResult | FileTransferError&gt;//改为: upload(fileUrl: string, url: string, options?: FileUploadOptions, trustAllHosts?: boolean): Promise&lt;FileUploadResult&gt;</code></pre><h3 id="在安卓下使用相册选择时-返回的图片路径不能再显示问题"><a href="#在安卓下使用相册选择时-返回的图片路径不能再显示问题" class="headerlink" title="在安卓下使用相册选择时, 返回的图片路径不能再显示问题"></a>在安卓下使用相册选择时, 返回的图片路径不能再显示问题</h3><ul><li>首先在这个例子使用的是cordova-plugin-camera组件(Cordova的相机插件)</li><li>首先引入需要的类</li><li>FilePath 这个类就是用来修复安卓上图片URI的问题的</li></ul><pre><code class="typescript">import { Camera, File, FilePath } from &#39;ionic-native&#39;;</code></pre><ul><li>使用 FilePath.resolveNativePath(imagePath) 这个方法来纠正图片URI</li></ul><pre><code class="typescript">Camera.getPicture(options).then((imagePath) =&gt; { // 特殊安卓图片库的处理 this.nativeFilePath = imagePath; if (this.pl.is(&#39;android&#39;) &amp;&amp; sourceType === Camera.PictureSourceType.PHOTOLIBRARY) {   FilePath.resolveNativePath(imagePath)   .then(filePath =&gt; {       this.nativeFilePath = filePath;       let currentName = imagePath.substring(imagePath.lastIndexOf(&#39;/&#39;) + 1, imagePath.lastIndexOf(&#39;?&#39;));   }); } else {   var currentName = imagePath.substr(imagePath.lastIndexOf(&#39;/&#39;) + 1); }}, err =&gt; { // this.presentToast(&#39;选择图片失败.&#39;);});</code></pre>]]></content>
      
      
      <categories>
          
          <category> Ionic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ionic 2 </tag>
            
            <tag> Angular 2 </tag>
            
            <tag> Hybird App </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
